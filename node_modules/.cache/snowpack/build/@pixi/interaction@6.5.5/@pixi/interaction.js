import { Point } from '@pixi/math';
import { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';
import { DisplayObject, TemporaryDisplayObject } from '@pixi/display';
import { EventEmitter } from '@pixi/utils';
import { ExtensionType } from '@pixi/core';

/*!
 * @pixi/interaction - v6.5.5
 * Compiled Fri, 30 Sep 2022 13:37:53 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = function() {
  function InteractionData2() {
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
    this.global = new Point();
    this.target = null;
    this.originalEvent = null;
    this.identifier = null;
    this.isPrimary = false;
    this.button = 0;
    this.buttons = 0;
    this.width = 0;
    this.height = 0;
    this.tiltX = 0;
    this.tiltY = 0;
    this.pointerType = null;
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
  }
  Object.defineProperty(InteractionData2.prototype, "pointerId", {
    get: function() {
      return this.identifier;
    },
    enumerable: false,
    configurable: true
  });
  InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  };
  InteractionData2.prototype.copyEvent = function(event) {
    if ("isPrimary" in event && event.isPrimary) {
      this.isPrimary = true;
    }
    this.button = "button" in event && event.button;
    var buttons = "buttons" in event && event.buttons;
    this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
    this.width = "width" in event && event.width;
    this.height = "height" in event && event.height;
    this.tiltX = "tiltX" in event && event.tiltX;
    this.tiltY = "tiltY" in event && event.tiltY;
    this.pointerType = "pointerType" in event && event.pointerType;
    this.pressure = "pressure" in event && event.pressure;
    this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
    this.twist = "twist" in event && event.twist || 0;
    this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
  };
  InteractionData2.prototype.reset = function() {
    this.isPrimary = false;
  };
  return InteractionData2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var InteractionEvent = function() {
  function InteractionEvent2() {
    this.stopped = false;
    this.stopsPropagatingAt = null;
    this.stopPropagationHint = false;
    this.target = null;
    this.currentTarget = null;
    this.type = null;
    this.data = null;
  }
  InteractionEvent2.prototype.stopPropagation = function() {
    this.stopped = true;
    this.stopPropagationHint = true;
    this.stopsPropagatingAt = this.currentTarget;
  };
  InteractionEvent2.prototype.reset = function() {
    this.stopped = false;
    this.stopsPropagatingAt = null;
    this.stopPropagationHint = false;
    this.currentTarget = null;
    this.target = null;
  };
  return InteractionEvent2;
}();
var InteractionTrackingData = function() {
  function InteractionTrackingData2(pointerId) {
    this._pointerId = pointerId;
    this._flags = InteractionTrackingData2.FLAGS.NONE;
  }
  InteractionTrackingData2.prototype._doSet = function(flag, yn) {
    if (yn) {
      this._flags = this._flags | flag;
    } else {
      this._flags = this._flags & ~flag;
    }
  };
  Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
    get: function() {
      return this._pointerId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
    get: function() {
      return this._flags;
    },
    set: function(flags) {
      this._flags = flags;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "none", {
    get: function() {
      return this._flags === InteractionTrackingData2.FLAGS.NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "over", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
    },
    enumerable: false,
    configurable: true
  });
  InteractionTrackingData2.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2
  });
  return InteractionTrackingData2;
}();
var TreeSearch = function() {
  function TreeSearch2() {
    this._tempPoint = new Point();
  }
  TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {
    var _a;
    if (!displayObject || !displayObject.visible) {
      return false;
    }
    var point = interactionEvent.data.global;
    interactive = displayObject.interactive || interactive;
    var hit = false;
    var interactiveParent = interactive;
    var hitTestChildren = true;
    if (displayObject.hitArea) {
      if (hitTest) {
        displayObject.worldTransform.applyInverse(point, this._tempPoint);
        if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
          hitTest = false;
          hitTestChildren = false;
        } else {
          hit = true;
        }
      }
      interactiveParent = false;
    } else if (displayObject._mask) {
      if (hitTest) {
        var maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
        if (maskObject && !((_a = maskObject.containsPoint) === null || _a === void 0 ? void 0 : _a.call(maskObject, point))) {
          hitTest = false;
        }
      }
    }
    if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
      var children = displayObject.children;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);
        if (childHit) {
          if (!child.parent) {
            continue;
          }
          interactiveParent = false;
          if (childHit) {
            if (interactionEvent.target) {
              hitTest = false;
            }
            hit = true;
          }
        }
      }
    }
    if (interactive) {
      if (hitTest && !interactionEvent.target) {
        if (!displayObject.hitArea && displayObject.containsPoint) {
          if (displayObject.containsPoint(point)) {
            hit = true;
          }
        }
      }
      if (displayObject.interactive) {
        if (hit && !interactionEvent.target) {
          interactionEvent.target = displayObject;
        }
        if (func) {
          func(interactionEvent, displayObject, !!hit);
        }
      }
    }
    return hit;
  };
  TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {
    this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);
  };
  return TreeSearch2;
}();
var interactiveTarget = {
  interactive: false,
  interactiveChildren: true,
  hitArea: null,
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(value) {
    if (value) {
      this.cursor = "pointer";
    } else if (this.cursor === "pointer") {
      this.cursor = null;
    }
  },
  cursor: null,
  get trackedPointers() {
    if (this._trackedPointers === void 0) {
      this._trackedPointers = {};
    }
    return this._trackedPointers;
  },
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1;
var hitTestEvent = {
  target: null,
  data: {
    global: null
  }
};
var InteractionManager = function(_super) {
  __extends(InteractionManager2, _super);
  function InteractionManager2(renderer, options) {
    var _this = _super.call(this) || this;
    options = options || {};
    _this.renderer = renderer;
    _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
    _this.interactionFrequency = options.interactionFrequency || 10;
    _this.mouse = new InteractionData();
    _this.mouse.identifier = MOUSE_POINTER_ID;
    _this.mouse.global.set(-999999);
    _this.activeInteractionData = {};
    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
    _this.interactionDataPool = [];
    _this.eventData = new InteractionEvent();
    _this.interactionDOMElement = null;
    _this.moveWhenInside = false;
    _this.eventsAdded = false;
    _this.tickerAdded = false;
    _this.mouseOverRenderer = !("PointerEvent" in globalThis);
    _this.supportsTouchEvents = "ontouchstart" in globalThis;
    _this.supportsPointerEvents = !!globalThis.PointerEvent;
    _this.onPointerUp = _this.onPointerUp.bind(_this);
    _this.processPointerUp = _this.processPointerUp.bind(_this);
    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    _this.onPointerDown = _this.onPointerDown.bind(_this);
    _this.processPointerDown = _this.processPointerDown.bind(_this);
    _this.onPointerMove = _this.onPointerMove.bind(_this);
    _this.processPointerMove = _this.processPointerMove.bind(_this);
    _this.onPointerOut = _this.onPointerOut.bind(_this);
    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    _this.onPointerOver = _this.onPointerOver.bind(_this);
    _this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    _this.currentCursorMode = null;
    _this.cursor = null;
    _this.resolution = 1;
    _this.delayedEvents = [];
    _this.search = new TreeSearch();
    _this._tempDisplayObject = new TemporaryDisplayObject();
    _this._eventListenerOptions = {capture: true, passive: false};
    _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
    _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
    return _this;
  }
  Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
    get: function() {
      return this._useSystemTicker;
    },
    set: function(useSystemTicker) {
      this._useSystemTicker = useSystemTicker;
      if (useSystemTicker) {
        this.addTickerListener();
      } else {
        this.removeTickerListener();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
    get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    },
    enumerable: false,
    configurable: true
  });
  InteractionManager2.prototype.hitTest = function(globalPoint, root) {
    hitTestEvent.target = null;
    hitTestEvent.data.global = globalPoint;
    if (!root) {
      root = this.lastObjectRendered;
    }
    this.processInteractive(hitTestEvent, root, null, true);
    return hitTestEvent.target;
  };
  InteractionManager2.prototype.setTargetElement = function(element, resolution) {
    if (resolution === void 0) {
      resolution = 1;
    }
    this.removeTickerListener();
    this.removeEvents();
    this.interactionDOMElement = element;
    this.resolution = resolution;
    this.addEvents();
    this.addTickerListener();
  };
  InteractionManager2.prototype.addTickerListener = function() {
    if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
      return;
    }
    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  };
  InteractionManager2.prototype.removeTickerListener = function() {
    if (!this.tickerAdded) {
      return;
    }
    Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  };
  InteractionManager2.prototype.addEvents = function() {
    if (this.eventsAdded || !this.interactionDOMElement) {
      return;
    }
    var style = this.interactionDOMElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "none";
      style.msTouchAction = "none";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "none";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
      globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
      globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
      globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
    }
    if (this.supportsTouchEvents) {
      this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
    }
    this.eventsAdded = true;
  };
  InteractionManager2.prototype.removeEvents = function() {
    if (!this.eventsAdded || !this.interactionDOMElement) {
      return;
    }
    var style = this.interactionDOMElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
      globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
      globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
      globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
    }
    if (this.supportsTouchEvents) {
      this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
    }
    this.interactionDOMElement = null;
    this.eventsAdded = false;
  };
  InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  };
  InteractionManager2.prototype.update = function() {
    if (!this.interactionDOMElement) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    this.cursor = null;
    for (var k in this.activeInteractionData) {
      if (this.activeInteractionData.hasOwnProperty(k)) {
        var interactionData = this.activeInteractionData[k];
        if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
        }
      }
    }
    this.setCursorMode(this.cursor);
  };
  InteractionManager2.prototype.setCursorMode = function(mode) {
    mode = mode || "default";
    var applyStyles = true;
    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursorMode === mode) {
      return;
    }
    this.currentCursorMode = mode;
    var style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.interactionDOMElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.interactionDOMElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.interactionDOMElement.style.cursor = mode;
    }
  };
  InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
    if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
      eventData.currentTarget = displayObject;
      eventData.type = eventString;
      displayObject.emit(eventString, eventData);
      if (displayObject[eventString]) {
        displayObject[eventString](eventData);
      }
    }
  };
  InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
    this.delayedEvents.push({displayObject, eventString, eventData});
  };
  InteractionManager2.prototype.mapPositionToPoint = function(point, x, y) {
    var rect;
    if (!this.interactionDOMElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.interactionDOMElement.getBoundingClientRect();
    }
    var resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
    point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
  };
  InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {
    var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);
    var delayedEvents = this.delayedEvents;
    if (!delayedEvents.length) {
      return hit;
    }
    interactionEvent.stopPropagationHint = false;
    var delayedLen = delayedEvents.length;
    this.delayedEvents = [];
    for (var i = 0; i < delayedLen; i++) {
      var _a = delayedEvents[i], displayObject_1 = _a.displayObject, eventString = _a.eventString, eventData = _a.eventData;
      if (eventData.stopsPropagatingAt === displayObject_1) {
        eventData.stopPropagationHint = true;
      }
      this.dispatchEvent(displayObject_1, eventString, eventData);
    }
    return hit;
  };
  InteractionManager2.prototype.onPointerDown = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
      if (cancelable) {
        originalEvent.preventDefault();
      }
    }
    var eventLen = events.length;
    for (var i = 0; i < eventLen; i++) {
      var event = events[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
      this.emit("pointerdown", interactionEvent);
      if (event.pointerType === "touch") {
        this.emit("touchstart", interactionEvent);
      } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
        var isRightButton = event.button === 2;
        this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
      }
    }
  };
  InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    if (hit) {
      if (!displayObject.trackedPointers[id]) {
        displayObject.trackedPointers[id] = new InteractionTrackingData(id);
      }
      this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
      if (data.pointerType === "touch") {
        this.dispatchEvent(displayObject, "touchstart", interactionEvent);
      } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
        var isRightButton = data.button === 2;
        if (isRightButton) {
          displayObject.trackedPointers[id].rightDown = true;
        } else {
          displayObject.trackedPointers[id].leftDown = true;
        }
        this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {
    var events = this.normalizeToPointerData(originalEvent);
    var eventLen = events.length;
    var target = originalEvent.target;
    if (originalEvent.composedPath && originalEvent.composedPath().length > 0) {
      target = originalEvent.composedPath()[0];
    }
    var eventAppend = target !== this.interactionDOMElement ? "outside" : "";
    for (var i = 0; i < eventLen; i++) {
      var event = events[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);
      this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        var isRightButton = event.button === 2;
        this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
      } else if (event.pointerType === "touch") {
        this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
        this.releaseInteractionDataForPointerId(event.pointerId);
      }
    }
  };
  InteractionManager2.prototype.onPointerCancel = function(event) {
    if (this.supportsTouchEvents && event.pointerType === "touch") {
      return;
    }
    this.onPointerComplete(event, true, this.processPointerCancel);
  };
  InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    if (displayObject.trackedPointers[id] !== void 0) {
      delete displayObject.trackedPointers[id];
      this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
      if (data.pointerType === "touch") {
        this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerUp = function(event) {
    if (this.supportsTouchEvents && event.pointerType === "touch") {
      return;
    }
    this.onPointerComplete(event, false, this.processPointerUp);
  };
  InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    var trackingData = displayObject.trackedPointers[id];
    var isTouch = data.pointerType === "touch";
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    var isMouseTap = false;
    if (isMouse) {
      var isRightButton = data.button === 2;
      var flags = InteractionTrackingData.FLAGS;
      var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
      var isDown = trackingData !== void 0 && trackingData.flags & test;
      if (hit) {
        this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
        if (isDown) {
          this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
          isMouseTap = true;
        }
      } else if (isDown) {
        this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
      }
      if (trackingData) {
        if (isRightButton) {
          trackingData.rightDown = false;
        } else {
          trackingData.leftDown = false;
        }
      }
    }
    if (hit) {
      this.dispatchEvent(displayObject, "pointerup", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchend", interactionEvent);
      }
      if (trackingData) {
        if (!isMouse || isMouseTap) {
          this.dispatchEvent(displayObject, "pointertap", interactionEvent);
        }
        if (isTouch) {
          this.dispatchEvent(displayObject, "tap", interactionEvent);
          trackingData.over = false;
        }
      }
    } else if (trackingData) {
      this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
      }
    }
    if (trackingData && trackingData.none) {
      delete displayObject.trackedPointers[id];
    }
  };
  InteractionManager2.prototype.onPointerMove = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    if (events[0].pointerType === "mouse" || events[0].pointerType === "pen") {
      this._didMove = true;
      this.cursor = null;
    }
    var eventLen = events.length;
    for (var i = 0; i < eventLen; i++) {
      var event = events[i];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
      this.emit("pointermove", interactionEvent);
      if (event.pointerType === "touch") {
        this.emit("touchmove", interactionEvent);
      }
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mousemove", interactionEvent);
      }
    }
    if (events[0].pointerType === "mouse") {
      this.setCursorMode(this.cursor);
    }
  };
  InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var isTouch = data.pointerType === "touch";
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    if (isMouse) {
      this.processPointerOverOut(interactionEvent, displayObject, hit);
    }
    if (!this.moveWhenInside || hit) {
      this.dispatchEvent(displayObject, "pointermove", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchmove", interactionEvent);
      }
      if (isMouse) {
        this.dispatchEvent(displayObject, "mousemove", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerOut = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    var event = events[0];
    if (event.pointerType === "mouse") {
      this.mouseOverRenderer = false;
      this.setCursorMode(null);
    }
    var interactionData = this.getInteractionDataForPointerId(event);
    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    interactionEvent.data.originalEvent = event;
    this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
    this.emit("pointerout", interactionEvent);
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      this.emit("mouseout", interactionEvent);
    } else {
      this.releaseInteractionDataForPointerId(interactionData.identifier);
    }
  };
  InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    var trackingData = displayObject.trackedPointers[id];
    if (hit && !trackingData) {
      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
    }
    if (trackingData === void 0) {
      return;
    }
    if (hit && this.mouseOverRenderer) {
      if (!trackingData.over) {
        trackingData.over = true;
        this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
        if (isMouse) {
          this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
        }
      }
      if (isMouse && this.cursor === null) {
        this.cursor = displayObject.cursor;
      }
    } else if (trackingData.over) {
      trackingData.over = false;
      this.dispatchEvent(displayObject, "pointerout", this.eventData);
      if (isMouse) {
        this.dispatchEvent(displayObject, "mouseout", interactionEvent);
      }
      if (trackingData.none) {
        delete displayObject.trackedPointers[id];
      }
    }
  };
  InteractionManager2.prototype.onPointerOver = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    var event = events[0];
    var interactionData = this.getInteractionDataForPointerId(event);
    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    interactionEvent.data.originalEvent = event;
    if (event.pointerType === "mouse") {
      this.mouseOverRenderer = true;
    }
    this.emit("pointerover", interactionEvent);
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      this.emit("mouseover", interactionEvent);
    }
  };
  InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
    var pointerId = event.pointerId;
    var interactionData;
    if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
      interactionData = this.mouse;
    } else if (this.activeInteractionData[pointerId]) {
      interactionData = this.activeInteractionData[pointerId];
    } else {
      interactionData = this.interactionDataPool.pop() || new InteractionData();
      interactionData.identifier = pointerId;
      this.activeInteractionData[pointerId] = interactionData;
    }
    interactionData.copyEvent(event);
    return interactionData;
  };
  InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
    var interactionData = this.activeInteractionData[pointerId];
    if (interactionData) {
      delete this.activeInteractionData[pointerId];
      interactionData.reset();
      this.interactionDataPool.push(interactionData);
    }
  };
  InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
    interactionEvent.data = interactionData;
    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
    if (pointerEvent.pointerType === "touch") {
      pointerEvent.globalX = interactionData.global.x;
      pointerEvent.globalY = interactionData.global.y;
    }
    interactionData.originalEvent = pointerEvent;
    interactionEvent.reset();
    return interactionEvent;
  };
  InteractionManager2.prototype.normalizeToPointerData = function(event) {
    var normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (var i = 0, li = event.changedTouches.length; i < li; i++) {
        var touch = event.changedTouches[i];
        if (typeof touch.button === "undefined") {
          touch.button = event.touches.length ? 1 : 0;
        }
        if (typeof touch.buttons === "undefined") {
          touch.buttons = event.touches.length ? 1 : 0;
        }
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined") {
          touch.width = touch.radiusX || 1;
        }
        if (typeof touch.height === "undefined") {
          touch.height = touch.radiusY || 1;
        }
        if (typeof touch.tiltX === "undefined") {
          touch.tiltX = 0;
        }
        if (typeof touch.tiltY === "undefined") {
          touch.tiltY = 0;
        }
        if (typeof touch.pointerType === "undefined") {
          touch.pointerType = "touch";
        }
        if (typeof touch.pointerId === "undefined") {
          touch.pointerId = touch.identifier || 0;
        }
        if (typeof touch.pressure === "undefined") {
          touch.pressure = touch.force || 0.5;
        }
        if (typeof touch.twist === "undefined") {
          touch.twist = 0;
        }
        if (typeof touch.tangentialPressure === "undefined") {
          touch.tangentialPressure = 0;
        }
        if (typeof touch.layerX === "undefined") {
          touch.layerX = touch.offsetX = touch.clientX;
        }
        if (typeof touch.layerY === "undefined") {
          touch.layerY = touch.offsetY = touch.clientY;
        }
        touch.isNormalized = true;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      var tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined") {
        tempEvent.isPrimary = true;
      }
      if (typeof tempEvent.width === "undefined") {
        tempEvent.width = 1;
      }
      if (typeof tempEvent.height === "undefined") {
        tempEvent.height = 1;
      }
      if (typeof tempEvent.tiltX === "undefined") {
        tempEvent.tiltX = 0;
      }
      if (typeof tempEvent.tiltY === "undefined") {
        tempEvent.tiltY = 0;
      }
      if (typeof tempEvent.pointerType === "undefined") {
        tempEvent.pointerType = "mouse";
      }
      if (typeof tempEvent.pointerId === "undefined") {
        tempEvent.pointerId = MOUSE_POINTER_ID;
      }
      if (typeof tempEvent.pressure === "undefined") {
        tempEvent.pressure = 0.5;
      }
      if (typeof tempEvent.twist === "undefined") {
        tempEvent.twist = 0;
      }
      if (typeof tempEvent.tangentialPressure === "undefined") {
        tempEvent.tangentialPressure = 0;
      }
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  };
  InteractionManager2.prototype.destroy = function() {
    this.removeEvents();
    this.removeTickerListener();
    this.removeAllListeners();
    this.renderer = null;
    this.mouse = null;
    this.eventData = null;
    this.interactionDOMElement = null;
    this.onPointerDown = null;
    this.processPointerDown = null;
    this.onPointerUp = null;
    this.processPointerUp = null;
    this.onPointerCancel = null;
    this.processPointerCancel = null;
    this.onPointerMove = null;
    this.processPointerMove = null;
    this.onPointerOut = null;
    this.processPointerOverOut = null;
    this.onPointerOver = null;
    this.search = null;
  };
  InteractionManager2.extension = {
    name: "interaction",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  };
  return InteractionManager2;
}(EventEmitter);

export { InteractionData, InteractionEvent, InteractionManager, InteractionTrackingData, interactiveTarget };
