import { BLEND_MODES, TYPES } from '@pixi/constants';
import { Container } from '@pixi/display';
import { hex2rgb, correctBlendMode, premultiplyRgba, premultiplyTint, createIndicesForQuads } from '@pixi/utils';
import { ExtensionType, ObjectRenderer, Shader, State, Geometry, Buffer } from '@pixi/core';
import { Matrix } from '@pixi/math';

/*!
 * @pixi/particle-container - v6.5.5
 * Compiled Fri, 30 Sep 2022 13:37:53 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var ParticleContainer = function(_super) {
  __extends(ParticleContainer2, _super);
  function ParticleContainer2(maxSize, properties, batchSize, autoResize) {
    if (maxSize === void 0) {
      maxSize = 1500;
    }
    if (batchSize === void 0) {
      batchSize = 16384;
    }
    if (autoResize === void 0) {
      autoResize = false;
    }
    var _this = _super.call(this) || this;
    var maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    _this._properties = [false, true, false, false, false];
    _this._maxSize = maxSize;
    _this._batchSize = batchSize;
    _this._buffers = null;
    _this._bufferUpdateIDs = [];
    _this._updateID = 0;
    _this.interactiveChildren = false;
    _this.blendMode = BLEND_MODES.NORMAL;
    _this.autoResize = autoResize;
    _this.roundPixels = true;
    _this.baseTexture = null;
    _this.setProperties(properties);
    _this._tint = 0;
    _this.tintRgb = new Float32Array(4);
    _this.tint = 16777215;
    return _this;
  }
  ParticleContainer2.prototype.setProperties = function(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  };
  ParticleContainer2.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  };
  Object.defineProperty(ParticleContainer2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
      hex2rgb(value, this.tintRgb);
    },
    enumerable: false,
    configurable: true
  });
  ParticleContainer2.prototype.render = function(renderer) {
    var _this = this;
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", function() {
          return _this.onChildrenChange(0);
        });
      }
    }
    renderer.batch.setObjectRenderer(renderer.plugins.particle);
    renderer.plugins.particle.render(this);
  };
  ParticleContainer2.prototype.onChildrenChange = function(smallestChildIndex) {
    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  };
  ParticleContainer2.prototype.dispose = function() {
    if (this._buffers) {
      for (var i = 0; i < this._buffers.length; ++i) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
    }
  };
  ParticleContainer2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  };
  return ParticleContainer2;
}(Container);
var ParticleBuffer = function() {
  function ParticleBuffer2(properties, dynamicPropertyFlags, size) {
    this.geometry = new Geometry();
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (var i = 0; i < properties.length; ++i) {
      var property = properties[i];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  ParticleBuffer2.prototype.initBuffers = function() {
    var geometry = this.geometry;
    var dynamicOffset = 0;
    this.indexBuffer = new Buffer(createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (var i = 0; i < this.dynamicProperties.length; ++i) {
      var property = this.dynamicProperties[i];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new Buffer(this.dynamicData, false, false);
    var staticOffset = 0;
    this.staticStride = 0;
    for (var i = 0; i < this.staticProperties.length; ++i) {
      var property = this.staticProperties[i];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new Buffer(this.staticData, true, false);
    for (var i = 0; i < this.dynamicProperties.length; ++i) {
      var property = this.dynamicProperties[i];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (var i = 0; i < this.staticProperties.length; ++i) {
      var property = this.staticProperties[i];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  };
  ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {
    for (var i = 0; i < this.dynamicProperties.length; i++) {
      var property = this.dynamicProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  };
  ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {
    for (var i = 0; i < this.staticProperties.length; i++) {
      var property = this.staticProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  };
  ParticleBuffer2.prototype.destroy = function() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  };
  return ParticleBuffer2;
}();
var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
var ParticleRenderer = function(_super) {
  __extends(ParticleRenderer2, _super);
  function ParticleRenderer2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.shader = null;
    _this.properties = null;
    _this.tempMatrix = new Matrix();
    _this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: _this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: _this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: _this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: _this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES.UNSIGNED_BYTE,
        uploadFunction: _this.uploadTint,
        offset: 0
      }
    ];
    _this.shader = Shader.from(vertex, fragment, {});
    _this.state = State.for2d();
    return _this;
  }
  ParticleRenderer2.prototype.render = function(container) {
    var children = container.children;
    var maxSize = container._maxSize;
    var batchSize = container._batchSize;
    var renderer = this.renderer;
    var totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    var buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    var baseTexture = children[0]._texture.baseTexture;
    var premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = correctBlendMode(container.blendMode, premultiplied);
    renderer.state.set(this.state);
    var gl = renderer.gl;
    var m = container.worldTransform.copyTo(this.tempMatrix);
    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m.toArray(true);
    this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, premultiplied);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    var updateStatic = false;
    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
      var amount = totalChildren - i;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      var buffer = buffers[j];
      buffer.uploadDynamic(children, i, amount);
      var bid = container._bufferUpdateIDs[j] || 0;
      updateStatic = updateStatic || buffer._updateID < bid;
      if (updateStatic) {
        buffer._updateID = container._updateID;
        buffer.uploadStatic(children, i, amount);
      }
      renderer.geometry.bind(buffer.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  };
  ParticleRenderer2.prototype.generateBuffers = function(container) {
    var buffers = [];
    var size = container._maxSize;
    var batchSize = container._batchSize;
    var dynamicPropertyFlags = container._properties;
    for (var i = 0; i < size; i += batchSize) {
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  };
  ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {
    var batchSize = container._batchSize;
    var dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  };
  ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset) {
    var w0 = 0;
    var w1 = 0;
    var h0 = 0;
    var h1 = 0;
    for (var i = 0; i < amount; ++i) {
      var sprite = children[startIndex + i];
      var texture = sprite._texture;
      var sx = sprite.scale.x;
      var sy = sprite.scale.y;
      var trim = texture.trim;
      var orig = texture.orig;
      if (trim) {
        w1 = trim.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; i++) {
      var spritePosition = children[startIndex + i].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; i++) {
      var spriteRotation = children[startIndex + i].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; ++i) {
      var textureUvs = children[startIndex + i]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  };
  ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset) {
    for (var i = 0; i < amount; ++i) {
      var sprite = children[startIndex + i];
      var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
      var alpha = sprite.alpha;
      var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
      array[offset] = argb;
      array[offset + stride] = argb;
      array[offset + stride * 2] = argb;
      array[offset + stride * 3] = argb;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  };
  ParticleRenderer2.extension = {
    name: "particle",
    type: ExtensionType.RendererPlugin
  };
  return ParticleRenderer2;
}(ObjectRenderer);

export { ParticleContainer, ParticleRenderer };
