import { CanvasRenderTarget } from '@pixi/utils';
import { Rectangle } from '@pixi/math';
import { RenderTexture, ExtensionType } from '@pixi/core';

/*!
 * @pixi/extract - v6.5.5
 * Compiled Fri, 30 Sep 2022 13:37:53 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle();
var BYTES_PER_PIXEL = 4;
var Extract = function() {
  function Extract2(renderer) {
    this.renderer = renderer;
  }
  Extract2.prototype.image = function(target, format, quality) {
    var image = new Image();
    image.src = this.base64(target, format, quality);
    return image;
  };
  Extract2.prototype.base64 = function(target, format, quality) {
    return this.canvas(target).toDataURL(format, quality);
  };
  Extract2.prototype.canvas = function(target, frame) {
    var renderer = this.renderer;
    var resolution;
    var flipY = false;
    var renderTexture;
    var generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = this.renderer.generateTexture(target);
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame !== null && frame !== void 0 ? frame : renderTexture.frame;
      flipY = false;
      renderer.renderTexture.bind(renderTexture);
    } else {
      resolution = renderer.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width;
        frame.height = renderer.height;
      }
      flipY = true;
      renderer.renderTexture.bind(null);
    }
    var width = Math.round(frame.width * resolution);
    var height = Math.round(frame.height * resolution);
    var canvasBuffer = new CanvasRenderTarget(width, height, 1);
    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    var gl = renderer.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
    var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
    Extract2.arrayPostDivide(webglPixels, canvasData.data);
    canvasBuffer.context.putImageData(canvasData, 0, 0);
    if (flipY) {
      var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
      target_1.context.scale(1, -1);
      target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
      canvasBuffer.destroy();
      canvasBuffer = target_1;
    }
    if (generated) {
      renderTexture.destroy(true);
    }
    return canvasBuffer.canvas;
  };
  Extract2.prototype.pixels = function(target, frame) {
    var renderer = this.renderer;
    var resolution;
    var renderTexture;
    var generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = this.renderer.generateTexture(target);
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame !== null && frame !== void 0 ? frame : renderTexture.frame;
      renderer.renderTexture.bind(renderTexture);
    } else {
      resolution = renderer.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width;
        frame.height = renderer.height;
      }
      renderer.renderTexture.bind(null);
    }
    var width = Math.round(frame.width * resolution);
    var height = Math.round(frame.height * resolution);
    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    var gl = renderer.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
    if (generated) {
      renderTexture.destroy(true);
    }
    Extract2.arrayPostDivide(webglPixels, webglPixels);
    return webglPixels;
  };
  Extract2.prototype.destroy = function() {
    this.renderer = null;
  };
  Extract2.arrayPostDivide = function(pixels, out) {
    for (var i = 0; i < pixels.length; i += 4) {
      var alpha = out[i + 3] = pixels[i + 3];
      if (alpha !== 0) {
        out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
        out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
        out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
      } else {
        out[i] = pixels[i];
        out[i + 1] = pixels[i + 1];
        out[i + 2] = pixels[i + 2];
      }
    }
  };
  Extract2.extension = {
    name: "extract",
    type: ExtensionType.RendererPlugin
  };
  return Extract2;
}();

export { Extract };
