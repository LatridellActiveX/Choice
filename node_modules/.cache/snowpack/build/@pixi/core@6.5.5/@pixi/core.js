import { settings } from '@pixi/settings';
import { ENV, ALPHA_MODES, SCALE_MODES, FORMATS, TYPES, TARGETS, MIPMAP_MODES, MSAA_QUALITY, BUFFER_TYPE, CLEAR_MODES, DRAW_MODES, BUFFER_BITS, MASK_TYPES, BLEND_MODES, GC_MODES, SAMPLER_TYPES, WRAP_MODES, RENDERER_TYPE, PRECISION } from '@pixi/constants';
import { isMobile, isPow2, BaseTextureCache, TextureCache, uid, getResolutionOfUrl, deprecation, nextPow2, getBufferType, ProgramCache, removeItems, hex2string, hex2rgb, premultiplyBlendMode, log2, premultiplyTint, EventEmitter, determineCrossOrigin, sayHello, isWebGLSupported } from '@pixi/utils';
import { extensions as extensions$1, ExtensionType } from '@pixi/extensions';
export * from '@pixi/extensions';
import { Runner } from '@pixi/runner';
import { Ticker } from '@pixi/ticker';
import { groupD8, Point, Matrix, Rectangle } from '@pixi/math';

/*!
 * @pixi/core - v6.5.5
 * Compiled Fri, 30 Sep 2022 13:37:53 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
var INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  var extension = "";
  if (typeof source === "string") {
    var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (var i = INSTALLED.length - 1; i >= 0; --i) {
    var ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    var arguments$1 = arguments;
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments$1[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) {
          t[p] = s[p];
        }
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
      t[p] = s[p];
    }
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {
        t[p[i]] = s[p[i]];
      }
    }
  }
  return t;
}
var Resource = function() {
  function Resource2(width, height) {
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new Runner("setRealSize");
    this.onUpdate = new Runner("update");
    this.onError = new Runner("onError");
  }
  Resource2.prototype.bind = function(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  };
  Resource2.prototype.unbind = function(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  };
  Resource2.prototype.resize = function(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  };
  Object.defineProperty(Resource2.prototype, "valid", {
    get: function() {
      return !!this._width && !!this._height;
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.update = function() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  };
  Resource2.prototype.load = function() {
    return Promise.resolve(this);
  };
  Object.defineProperty(Resource2.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Resource2.prototype, "height", {
    get: function() {
      return this._height;
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
    return false;
  };
  Resource2.prototype.dispose = function() {
  };
  Resource2.prototype.destroy = function() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  };
  Resource2.test = function(_source, _extension) {
    return false;
  };
  return Resource2;
}();
var BufferResource = function(_super) {
  __extends(BufferResource2, _super);
  function BufferResource2(source, options) {
    var _this = this;
    var _a = options || {}, width = _a.width, height = _a.height;
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    _this = _super.call(this, width, height) || this;
    _this.data = source;
    return _this;
  }
  BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    var gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  };
  BufferResource2.prototype.dispose = function() {
    this.data = null;
  };
  BufferResource2.test = function(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  };
  return BufferResource2;
}(Resource);
var defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
};
var BaseTexture = function(_super) {
  __extends(BaseTexture2, _super);
  function BaseTexture2(resource, options) {
    if (resource === void 0) {
      resource = null;
    }
    if (options === void 0) {
      options = null;
    }
    var _this = _super.call(this) || this;
    options = options || {};
    var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
    if (resource && !(resource instanceof Resource)) {
      resource = autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    _this.resolution = resolution || settings.RESOLUTION;
    _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;
    _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;
    _this._mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
    _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
    _this._wrapMode = wrapMode || settings.WRAP_MODE;
    _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
    _this.format = format || FORMATS.RGBA;
    _this.type = type || TYPES.UNSIGNED_BYTE;
    _this.target = target || TARGETS.TEXTURE_2D;
    _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES.UNPACK;
    _this.uid = uid();
    _this.touched = 0;
    _this.isPowerOfTwo = false;
    _this._refreshPOT();
    _this._glTextures = {};
    _this.dirtyId = 0;
    _this.dirtyStyleId = 0;
    _this.cacheId = null;
    _this.valid = width > 0 && height > 0;
    _this.textureCacheIds = [];
    _this.destroyed = false;
    _this.resource = null;
    _this._batchEnabled = 0;
    _this._batchLocation = 0;
    _this.parentTextureArray = null;
    _this.setResource(resource);
    return _this;
  }
  Object.defineProperty(BaseTexture2.prototype, "realWidth", {
    get: function() {
      return Math.round(this.width * this.resolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "realHeight", {
    get: function() {
      return Math.round(this.height * this.resolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "mipmap", {
    get: function() {
      return this._mipmap;
    },
    set: function(value) {
      if (this._mipmap !== value) {
        this._mipmap = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "scaleMode", {
    get: function() {
      return this._scaleMode;
    },
    set: function(value) {
      if (this._scaleMode !== value) {
        this._scaleMode = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapMode", {
    get: function() {
      return this._wrapMode;
    },
    set: function(value) {
      if (this._wrapMode !== value) {
        this._wrapMode = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
    var dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  };
  BaseTexture2.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  };
  BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  };
  BaseTexture2.prototype._refreshPOT = function() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  };
  BaseTexture2.prototype.setResolution = function(resolution) {
    var oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  };
  BaseTexture2.prototype.setResource = function(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  };
  BaseTexture2.prototype.update = function() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  };
  BaseTexture2.prototype.onError = function(event) {
    this.emit("error", this, event);
  };
  BaseTexture2.prototype.destroy = function() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete BaseTextureCache[this.cacheId];
      delete TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    BaseTexture2.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  };
  BaseTexture2.prototype.dispose = function() {
    this.emit("dispose", this);
  };
  BaseTexture2.prototype.castToBaseTexture = function() {
    return this;
  };
  BaseTexture2.from = function(source, options, strict) {
    if (strict === void 0) {
      strict = settings.STRICT_TEXTURE_CACHE;
    }
    var isFrame = typeof source === "string";
    var cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source._pixiId = prefix + "_" + uid();
      }
      cacheId = source._pixiId;
    }
    var baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
    }
    if (!baseTexture) {
      baseTexture = new BaseTexture2(source, options);
      baseTexture.cacheId = cacheId;
      BaseTexture2.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  };
  BaseTexture2.fromBuffer = function(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    var resource = new BufferResource(buffer, {width, height});
    var type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
    return new BaseTexture2(resource, Object.assign(defaultBufferOptions, options || {width, height, type}));
  };
  BaseTexture2.addToCache = function(baseTexture, id) {
    if (id) {
      if (baseTexture.textureCacheIds.indexOf(id) === -1) {
        baseTexture.textureCacheIds.push(id);
      }
      if (BaseTextureCache[id]) {
        console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
      }
      BaseTextureCache[id] = baseTexture;
    }
  };
  BaseTexture2.removeFromCache = function(baseTexture) {
    if (typeof baseTexture === "string") {
      var baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index > -1) {
          baseTextureFromCache.textureCacheIds.splice(index, 1);
        }
        delete BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture && baseTexture.textureCacheIds) {
      for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
        delete BaseTextureCache[baseTexture.textureCacheIds[i]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  };
  BaseTexture2._globalBatch = 0;
  return BaseTexture2;
}(EventEmitter);
var AbstractMultiResource = function(_super) {
  __extends(AbstractMultiResource2, _super);
  function AbstractMultiResource2(length, options) {
    var _this = this;
    var _a = options || {}, width = _a.width, height = _a.height;
    _this = _super.call(this, width, height) || this;
    _this.items = [];
    _this.itemDirtyIds = [];
    for (var i = 0; i < length; i++) {
      var partTexture = new BaseTexture();
      _this.items.push(partTexture);
      _this.itemDirtyIds.push(-2);
    }
    _this.length = length;
    _this._load = null;
    _this.baseTexture = null;
    return _this;
  }
  AbstractMultiResource2.prototype.initFromArray = function(resources2, options) {
    for (var i = 0; i < this.length; i++) {
      if (!resources2[i]) {
        continue;
      }
      if (resources2[i].castToBaseTexture) {
        this.addBaseTextureAt(resources2[i].castToBaseTexture(), i);
      } else if (resources2[i] instanceof Resource) {
        this.addResourceAt(resources2[i], i);
      } else {
        this.addResourceAt(autoDetectResource(resources2[i], options), i);
      }
    }
  };
  AbstractMultiResource2.prototype.dispose = function() {
    for (var i = 0, len = this.length; i < len; i++) {
      this.items[i].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  };
  AbstractMultiResource2.prototype.addResourceAt = function(resource, index) {
    if (!this.items[index]) {
      throw new Error("Index " + index + " is out of bounds");
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index].setResource(resource);
    return this;
  };
  AbstractMultiResource2.prototype.bind = function(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    _super.prototype.bind.call(this, baseTexture);
    for (var i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = baseTexture;
      this.items[i].on("update", baseTexture.update, baseTexture);
    }
  };
  AbstractMultiResource2.prototype.unbind = function(baseTexture) {
    _super.prototype.unbind.call(this, baseTexture);
    for (var i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = null;
      this.items[i].off("update", baseTexture.update, baseTexture);
    }
  };
  AbstractMultiResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    var resources2 = this.items.map(function(item) {
      return item.resource;
    }).filter(function(item) {
      return item;
    });
    var promises = resources2.map(function(item) {
      return item.load();
    });
    this._load = Promise.all(promises).then(function() {
      var _a = _this.items[0], realWidth = _a.realWidth, realHeight = _a.realHeight;
      _this.resize(realWidth, realHeight);
      return Promise.resolve(_this);
    });
    return this._load;
  };
  return AbstractMultiResource2;
}(Resource);
var ArrayResource = function(_super) {
  __extends(ArrayResource2, _super);
  function ArrayResource2(source, options) {
    var _this = this;
    var _a = options || {}, width = _a.width, height = _a.height;
    var urls;
    var length;
    if (Array.isArray(source)) {
      urls = source;
      length = source.length;
    } else {
      length = source;
    }
    _this = _super.call(this, length, {width, height}) || this;
    if (urls) {
      _this.initFromArray(urls, options);
    }
    return _this;
  }
  ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  };
  ArrayResource2.prototype.bind = function(baseTexture) {
    _super.prototype.bind.call(this, baseTexture);
    baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
  };
  ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {
    var _a = this, length = _a.length, itemDirtyIds = _a.itemDirtyIds, items = _a.items;
    var gl = renderer.gl;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
    }
    for (var i = 0; i < length; i++) {
      var item = items[i];
      if (itemDirtyIds[i] < item.dirtyId) {
        itemDirtyIds[i] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  };
  return ArrayResource2;
}(AbstractMultiResource);
var BaseImageResource = function(_super) {
  __extends(BaseImageResource2, _super);
  function BaseImageResource2(source) {
    var _this = this;
    var sourceAny = source;
    var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    _this = _super.call(this, width, height) || this;
    _this.source = source;
    _this.noSubImage = false;
    return _this;
  }
  BaseImageResource2.crossOrigin = function(element, url, crossorigin) {
    if (crossorigin === void 0 && url.indexOf("data:") !== 0) {
      element.crossOrigin = determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  };
  BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {
    var gl = renderer.gl;
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    source = source || this.source;
    if (source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (source instanceof HTMLVideoElement) {
      if (source.readyState <= 1) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  };
  BaseImageResource2.prototype.update = function() {
    if (this.destroyed) {
      return;
    }
    var source = this.source;
    var width = source.naturalWidth || source.videoWidth || source.width;
    var height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    _super.prototype.update.call(this);
  };
  BaseImageResource2.prototype.dispose = function() {
    this.source = null;
  };
  return BaseImageResource2;
}(Resource);
var CanvasResource = function(_super) {
  __extends(CanvasResource2, _super);
  function CanvasResource2(source) {
    return _super.call(this, source) || this;
  }
  CanvasResource2.test = function(source) {
    var OffscreenCanvas = globalThis.OffscreenCanvas;
    if (OffscreenCanvas && source instanceof OffscreenCanvas) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  };
  return CanvasResource2;
}(BaseImageResource);
var CubeResource = function(_super) {
  __extends(CubeResource2, _super);
  function CubeResource2(source, options) {
    var _this = this;
    var _a = options || {}, width = _a.width, height = _a.height, autoLoad = _a.autoLoad, linkBaseTexture = _a.linkBaseTexture;
    if (source && source.length !== CubeResource2.SIDES) {
      throw new Error("Invalid length. Got " + source.length + ", expected 6");
    }
    _this = _super.call(this, 6, {width, height}) || this;
    for (var i = 0; i < CubeResource2.SIDES; i++) {
      _this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
    }
    _this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      _this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  CubeResource2.prototype.bind = function(baseTexture) {
    _super.prototype.bind.call(this, baseTexture);
    baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
  };
  CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index, linkBaseTexture) {
    if (!this.items[index]) {
      throw new Error("Index " + index + " is out of bounds");
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw new Error("CubeResource does not support copying of renderTexture.");
      }
    } else {
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index] = baseTexture;
    return this;
  };
  CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {
    var dirty = this.itemDirtyIds;
    for (var i = 0; i < CubeResource2.SIDES; i++) {
      var side = this.items[i];
      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer, side, glTexture);
          dirty[i] = side.dirtyId;
        } else if (dirty[i] < -1) {
          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i] = -1;
        }
      }
    }
    return true;
  };
  CubeResource2.test = function(source) {
    return Array.isArray(source) && source.length === CubeResource2.SIDES;
  };
  CubeResource2.SIDES = 6;
  return CubeResource2;
}(AbstractMultiResource);
var ImageResource = function(_super) {
  __extends(ImageResource2, _super);
  function ImageResource2(source, options) {
    var _this = this;
    options = options || {};
    if (!(source instanceof HTMLImageElement)) {
      var imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    _this = _super.call(this, source) || this;
    if (!source.complete && !!_this._width && !!_this._height) {
      _this._width = 0;
      _this._height = 0;
    }
    _this.url = source.src;
    _this._process = null;
    _this.preserveBitmap = false;
    _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    _this.bitmap = null;
    _this._load = null;
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  ImageResource2.prototype.load = function(createBitmap) {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise(function(resolve, reject) {
      var source = _this.source;
      _this.url = source.src;
      var completed = function() {
        if (_this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        _this.resize(source.width, source.height);
        _this._load = null;
        if (_this.createBitmap) {
          resolve(_this.process());
        } else {
          resolve(_this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = function(event) {
          reject(event);
          _this.onError.emit(event);
        };
      }
    });
    return this._load;
  };
  ImageResource2.prototype.process = function() {
    var _this = this;
    var source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    var createImageBitmap = globalThis.createImageBitmap;
    var cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then(function(r) {
      return r.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, 0, 0, source.width, source.height, {
        premultiplyAlpha: _this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
      });
    }).then(function(bitmap) {
      if (_this.destroyed) {
        return Promise.reject();
      }
      _this.bitmap = bitmap;
      _this.update();
      _this._process = null;
      return Promise.resolve(_this);
    });
    return this._process;
  };
  ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      var flag = true;
      var glTextures = baseTexture._glTextures;
      for (var key in glTextures) {
        var otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  };
  ImageResource2.prototype.dispose = function() {
    this.source.onload = null;
    this.source.onerror = null;
    _super.prototype.dispose.call(this);
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  };
  ImageResource2.test = function(source) {
    return typeof source === "string" || source instanceof HTMLImageElement;
  };
  return ImageResource2;
}(BaseImageResource);
var SVGResource = function(_super) {
  __extends(SVGResource2, _super);
  function SVGResource2(sourceBase64, options) {
    var _this = this;
    options = options || {};
    _this = _super.call(this, settings.ADAPTER.createCanvas()) || this;
    _this._width = 0;
    _this._height = 0;
    _this.svg = sourceBase64;
    _this.scale = options.scale || 1;
    _this._overrideWidth = options.width;
    _this._overrideHeight = options.height;
    _this._resolve = null;
    _this._crossorigin = options.crossorigin;
    _this._load = null;
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  SVGResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(function(resolve) {
      _this._resolve = function() {
        _this.resize(_this.source.width, _this.source.height);
        resolve(_this);
      };
      if (SVGResource2.SVG_XML.test(_this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
      }
      _this._loadSvg();
    });
    return this._load;
  };
  SVGResource2.prototype._loadSvg = function() {
    var _this = this;
    var tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = function(event) {
      if (!_this._resolve) {
        return;
      }
      tempImage.onerror = null;
      _this.onError.emit(event);
    };
    tempImage.onload = function() {
      if (!_this._resolve) {
        return;
      }
      var svgWidth = tempImage.width;
      var svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      var width = svgWidth * _this.scale;
      var height = svgHeight * _this.scale;
      if (_this._overrideWidth || _this._overrideHeight) {
        width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
        height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      var canvas = _this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = "canvas_" + uid();
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      _this._resolve();
      _this._resolve = null;
    };
  };
  SVGResource2.getSize = function(svgString) {
    var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
    var size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  };
  SVGResource2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._resolve = null;
    this._crossorigin = null;
  };
  SVGResource2.test = function(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && SVGResource2.SVG_XML.test(source);
  };
  SVGResource2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
  SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
  return SVGResource2;
}(BaseImageResource);
var VideoResource = function(_super) {
  __extends(VideoResource2, _super);
  function VideoResource2(source, options) {
    var _this = this;
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      var videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      var firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (var i = 0; i < source.length; ++i) {
        var sourceElement = document.createElement("source");
        var _a = source[i], src = _a.src, mime = _a.mime;
        src = src || source[i];
        var baseSrc = src.split("?").shift().toLowerCase();
        var ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    _this = _super.call(this, source) || this;
    _this.noSubImage = true;
    _this._autoUpdate = true;
    _this._isConnectedToTicker = false;
    _this._updateFPS = options.updateFPS || 0;
    _this._msToNextUpdate = 0;
    _this.autoPlay = options.autoPlay !== false;
    _this._load = null;
    _this._resolve = null;
    _this._onCanPlay = _this._onCanPlay.bind(_this);
    _this._onError = _this._onError.bind(_this);
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  VideoResource2.prototype.update = function(_deltaTime) {
    if (!this.destroyed) {
      var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        _super.prototype.update.call(this);
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  };
  VideoResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    var source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise(function(resolve) {
      if (_this.valid) {
        resolve(_this);
      } else {
        _this._resolve = resolve;
        source.load();
      }
    });
    return this._load;
  };
  VideoResource2.prototype._onError = function(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  };
  VideoResource2.prototype._isSourcePlaying = function() {
    var source = this.source;
    return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
  };
  VideoResource2.prototype._isSourceReady = function() {
    var source = this.source;
    return source.readyState === 3 || source.readyState === 4;
  };
  VideoResource2.prototype._onPlayStart = function() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  };
  VideoResource2.prototype._onPlayStop = function() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  };
  VideoResource2.prototype._onCanPlay = function() {
    var source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    var valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  };
  VideoResource2.prototype.dispose = function() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    var source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    _super.prototype.dispose.call(this);
  };
  Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VideoResource2.prototype, "updateFPS", {
    get: function() {
      return this._updateFPS;
    },
    set: function(value) {
      if (value !== this._updateFPS) {
        this._updateFPS = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  VideoResource2.test = function(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
  };
  VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
  VideoResource2.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  return VideoResource2;
}(BaseImageResource);
var ImageBitmapResource = function(_super) {
  __extends(ImageBitmapResource2, _super);
  function ImageBitmapResource2(source) {
    return _super.call(this, source) || this;
  }
  ImageBitmapResource2.test = function(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && source instanceof ImageBitmap;
  };
  return ImageBitmapResource2;
}(BaseImageResource);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var _resources = {
  __proto__: null,
  Resource,
  BaseImageResource,
  INSTALLED,
  autoDetectResource,
  AbstractMultiResource,
  ArrayResource,
  BufferResource,
  CanvasResource,
  CubeResource,
  ImageResource,
  SVGResource,
  VideoResource,
  ImageBitmapResource
};
var DepthResource = function(_super) {
  __extends(DepthResource2, _super);
  function DepthResource2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    var gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  };
  return DepthResource2;
}(BufferResource);
var Framebuffer = function() {
  function Framebuffer2(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new Runner("disposeFramebuffer");
    this.multisample = MSAA_QUALITY.NONE;
  }
  Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
    get: function() {
      return this.colorTextures[0];
    },
    enumerable: false,
    configurable: true
  });
  Framebuffer2.prototype.addColorTexture = function(index, texture) {
    if (index === void 0) {
      index = 0;
    }
    this.colorTextures[index] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.addDepthTexture = function(texture) {
    this.depthTexture = texture || new BaseTexture(new DepthResource(null, {width: this.width, height: this.height}), {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.enableDepth = function() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.enableStencil = function() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.resize = function(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height) {
      return;
    }
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (var i = 0; i < this.colorTextures.length; i++) {
      var texture = this.colorTextures[i];
      var resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      var resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  };
  Framebuffer2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Framebuffer2.prototype.destroyDepthTexture = function() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  };
  return Framebuffer2;
}();
var BaseRenderTexture = function(_super) {
  __extends(BaseRenderTexture2, _super);
  function BaseRenderTexture2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = this;
    if (typeof options === "number") {
      var width = arguments[0];
      var height = arguments[1];
      var scaleMode = arguments[2];
      var resolution = arguments[3];
      options = {width, height, scaleMode, resolution};
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY.NONE;
    _this = _super.call(this, null, options) || this;
    _this.mipmap = MIPMAP_MODES.OFF;
    _this.valid = true;
    _this.clearColor = [0, 0, 0, 0];
    _this.framebuffer = new Framebuffer(_this.realWidth, _this.realHeight).addColorTexture(0, _this);
    _this.framebuffer.multisample = options.multisample;
    _this.maskStack = [];
    _this.filterStack = [{}];
    return _this;
  }
  BaseRenderTexture2.prototype.resize = function(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  };
  BaseRenderTexture2.prototype.dispose = function() {
    this.framebuffer.dispose();
    _super.prototype.dispose.call(this);
  };
  BaseRenderTexture2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  };
  return BaseRenderTexture2;
}(BaseTexture);
var TextureUvs = function() {
  function TextureUvs2() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  TextureUvs2.prototype.set = function(frame, baseFrame, rotate) {
    var tw = baseFrame.width;
    var th = baseFrame.height;
    if (rotate) {
      var w2 = frame.width / 2 / tw;
      var h2 = frame.height / 2 / th;
      var cX = frame.x / tw + w2;
      var cY = frame.y / th + h2;
      rotate = groupD8.add(rotate, groupD8.NW);
      this.x0 = cX + w2 * groupD8.uX(rotate);
      this.y0 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x1 = cX + w2 * groupD8.uX(rotate);
      this.y1 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x2 = cX + w2 * groupD8.uX(rotate);
      this.y2 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x3 = cX + w2 * groupD8.uX(rotate);
      this.y3 = cY + h2 * groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  };
  TextureUvs2.prototype.toString = function() {
    return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
  };
  return TextureUvs2;
}();
var DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
var Texture = function(_super) {
  __extends(Texture2, _super);
  function Texture2(baseTexture, frame, orig, trim, rotate, anchor) {
    var _this = _super.call(this) || this;
    _this.noFrame = false;
    if (!frame) {
      _this.noFrame = true;
      frame = new Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture2) {
      baseTexture = baseTexture.baseTexture;
    }
    _this.baseTexture = baseTexture;
    _this._frame = frame;
    _this.trim = trim;
    _this.valid = false;
    _this._uvs = DEFAULT_UVS;
    _this.uvMatrix = null;
    _this.orig = orig || frame;
    _this._rotate = Number(rotate || 0);
    if (rotate === true) {
      _this._rotate = 2;
    } else if (_this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
    _this._updateID = 0;
    _this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
    } else if (_this.noFrame) {
      if (baseTexture.valid) {
        _this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      _this.frame = frame;
    }
    if (_this.noFrame) {
      baseTexture.on("update", _this.onBaseTextureUpdated, _this);
    }
    return _this;
  }
  Texture2.prototype.update = function() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  };
  Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  };
  Texture2.prototype.destroy = function(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        var resource = this.baseTexture.resource;
        if (resource && resource.url && TextureCache[resource.url]) {
          Texture2.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture2.removeFromCache(this);
    this.textureCacheIds = null;
  };
  Texture2.prototype.clone = function() {
    var clonedFrame = this._frame.clone();
    var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    var clonedTexture = new Texture2(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  };
  Texture2.prototype.updateUvs = function() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  };
  Texture2.from = function(source, options, strict) {
    if (options === void 0) {
      options = {};
    }
    if (strict === void 0) {
      strict = settings.STRICT_TEXTURE_CACHE;
    }
    var isFrame = typeof source === "string";
    var cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source.cacheId = prefix + "-" + uid();
        BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        var prefix = options && options.pixiIdPrefix || "pixiid";
        source._pixiId = prefix + "_" + uid();
      }
      cacheId = source._pixiId;
    }
    var texture = TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
    }
    if (!texture && !(source instanceof BaseTexture)) {
      if (!options.resolution) {
        options.resolution = getResolutionOfUrl(source);
      }
      texture = new Texture2(new BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture2.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture) {
      texture = new Texture2(source);
      Texture2.addToCache(texture, cacheId);
    }
    return texture;
  };
  Texture2.fromURL = function(url, options) {
    var resourceOptions = Object.assign({autoLoad: false}, options === null || options === void 0 ? void 0 : options.resourceOptions);
    var texture = Texture2.from(url, Object.assign({resourceOptions}, options), false);
    var resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(function() {
      return Promise.resolve(texture);
    });
  };
  Texture2.fromBuffer = function(buffer, width, height, options) {
    return new Texture2(BaseTexture.fromBuffer(buffer, width, height, options));
  };
  Texture2.fromLoader = function(source, imageUrl, name, options) {
    var baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: settings.SCALE_MODE,
      resolution: getResolutionOfUrl(imageUrl)
    }, options));
    var resource = baseTexture.resource;
    if (resource instanceof ImageResource) {
      resource.url = imageUrl;
    }
    var texture = new Texture2(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    BaseTexture.addToCache(texture.baseTexture, name);
    Texture2.addToCache(texture, name);
    if (name !== imageUrl) {
      BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture2.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise(function(resolve) {
      texture.baseTexture.once("loaded", function() {
        return resolve(texture);
      });
    });
  };
  Texture2.addToCache = function(texture, id) {
    if (id) {
      if (texture.textureCacheIds.indexOf(id) === -1) {
        texture.textureCacheIds.push(id);
      }
      if (TextureCache[id]) {
        console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
      }
      TextureCache[id] = texture;
    }
  };
  Texture2.removeFromCache = function(texture) {
    if (typeof texture === "string") {
      var textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        var index = textureFromCache.textureCacheIds.indexOf(texture);
        if (index > -1) {
          textureFromCache.textureCacheIds.splice(index, 1);
        }
        delete TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture && texture.textureCacheIds) {
      for (var i = 0; i < texture.textureCacheIds.length; ++i) {
        if (TextureCache[texture.textureCacheIds[i]] === texture) {
          delete TextureCache[texture.textureCacheIds[i]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  };
  Object.defineProperty(Texture2.prototype, "resolution", {
    get: function() {
      return this.baseTexture.resolution;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "frame", {
    get: function() {
      return this._frame;
    },
    set: function(frame) {
      this._frame = frame;
      this.noFrame = false;
      var x = frame.x, y = frame.y, width = frame.width, height = frame.height;
      var xNotFit = x + width > this.baseTexture.width;
      var yNotFit = y + height > this.baseTexture.height;
      if (xNotFit || yNotFit) {
        var relationship = xNotFit && yNotFit ? "and" : "or";
        var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + this.baseTexture.width;
        var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
      }
      this.valid = width && height && this.baseTexture.valid;
      if (!this.trim && !this.rotate) {
        this.orig = frame;
      }
      if (this.valid) {
        this.updateUvs();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "rotate", {
    get: function() {
      return this._rotate;
    },
    set: function(rotate) {
      this._rotate = rotate;
      if (this.valid) {
        this.updateUvs();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "width", {
    get: function() {
      return this.orig.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "height", {
    get: function() {
      return this.orig.height;
    },
    enumerable: false,
    configurable: true
  });
  Texture2.prototype.castToBaseTexture = function() {
    return this.baseTexture;
  };
  Object.defineProperty(Texture2, "EMPTY", {
    get: function() {
      if (!Texture2._EMPTY) {
        Texture2._EMPTY = new Texture2(new BaseTexture());
        removeAllHandlers(Texture2._EMPTY);
        removeAllHandlers(Texture2._EMPTY.baseTexture);
      }
      return Texture2._EMPTY;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2, "WHITE", {
    get: function() {
      if (!Texture2._WHITE) {
        var canvas = settings.ADAPTER.createCanvas(16, 16);
        var context2 = canvas.getContext("2d");
        canvas.width = 16;
        canvas.height = 16;
        context2.fillStyle = "white";
        context2.fillRect(0, 0, 16, 16);
        Texture2._WHITE = new Texture2(BaseTexture.from(canvas));
        removeAllHandlers(Texture2._WHITE);
        removeAllHandlers(Texture2._WHITE.baseTexture);
      }
      return Texture2._WHITE;
    },
    enumerable: false,
    configurable: true
  });
  return Texture2;
}(EventEmitter);
var RenderTexture = function(_super) {
  __extends(RenderTexture2, _super);
  function RenderTexture2(baseRenderTexture, frame) {
    var _this = _super.call(this, baseRenderTexture, frame) || this;
    _this.valid = true;
    _this.filterFrame = null;
    _this.filterPoolKey = null;
    _this.updateUvs();
    return _this;
  }
  Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
    get: function() {
      return this.baseTexture.framebuffer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTexture2.prototype, "multisample", {
    get: function() {
      return this.framebuffer.multisample;
    },
    set: function(value) {
      this.framebuffer.multisample = value;
    },
    enumerable: false,
    configurable: true
  });
  RenderTexture2.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {
    if (resizeBaseTexture === void 0) {
      resizeBaseTexture = true;
    }
    var resolution = this.baseTexture.resolution;
    var width = Math.round(desiredWidth * resolution) / resolution;
    var height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  };
  RenderTexture2.prototype.setResolution = function(resolution) {
    var baseTexture = this.baseTexture;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  };
  RenderTexture2.create = function(options) {
    var arguments$1 = arguments;
    var rest = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      rest[_i - 1] = arguments$1[_i];
    }
    if (typeof options === "number") {
      deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
      options = {
        width: options,
        height: rest[0],
        scaleMode: rest[1],
        resolution: rest[2]
      };
    }
    return new RenderTexture2(new BaseRenderTexture(options));
  };
  return RenderTexture2;
}(Texture);
var RenderTexturePool = function() {
  function RenderTexturePool2(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight, multisample) {
    if (multisample === void 0) {
      multisample = MSAA_QUALITY.NONE;
    }
    var baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  };
  RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (multisample === void 0) {
      multisample = MSAA_QUALITY.NONE;
    }
    var key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    var renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  };
  RenderTexturePool2.prototype.getFilterTexture = function(input, resolution, multisample) {
    var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  };
  RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
    var key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  };
  RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
    this.returnTexture(renderTexture);
  };
  RenderTexturePool2.prototype.clear = function(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (var i in this.texturePool) {
        var textures = this.texturePool[i];
        if (textures) {
          for (var j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  };
  RenderTexturePool2.prototype.setScreenSize = function(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (var i in this.texturePool) {
      if (!(Number(i) < 0)) {
        continue;
      }
      var textures = this.texturePool[i];
      if (textures) {
        for (var j = 0; j < textures.length; j++) {
          textures[j].destroy(true);
        }
      }
      this.texturePool[i] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  };
  RenderTexturePool2.SCREEN_KEY = -1;
  return RenderTexturePool2;
}();
var Attribute = function() {
  function Attribute2(buffer, size, normalized, type, stride, start, instance) {
    if (size === void 0) {
      size = 0;
    }
    if (normalized === void 0) {
      normalized = false;
    }
    if (type === void 0) {
      type = TYPES.FLOAT;
    }
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
  }
  Attribute2.prototype.destroy = function() {
    this.buffer = null;
  };
  Attribute2.from = function(buffer, size, normalized, type, stride) {
    return new Attribute2(buffer, size, normalized, type, stride);
  };
  return Attribute2;
}();
var UID$4 = 0;
var Buffer = function() {
  function Buffer2(data, _static, index) {
    if (_static === void 0) {
      _static = true;
    }
    if (index === void 0) {
      index = false;
    }
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index;
    this.static = _static;
    this.id = UID$4++;
    this.disposeRunner = new Runner("disposeBuffer");
  }
  Buffer2.prototype.update = function(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  };
  Buffer2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Buffer2.prototype.destroy = function() {
    this.dispose();
    this.data = null;
  };
  Object.defineProperty(Buffer2.prototype, "index", {
    get: function() {
      return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    },
    set: function(value) {
      this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
    },
    enumerable: false,
    configurable: true
  });
  Buffer2.from = function(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer2(data);
  };
  return Buffer2;
}();
var map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  var buffer = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i = 0; i < arrays.length; i++) {
    var size = sizes[i];
    var array = arrays[i];
    var type = getBufferType(array);
    if (!views[type]) {
      views[type] = new map$1[type](buffer);
    }
    out = views[type];
    for (var j = 0; j < array.length; j++) {
      var indexStart = (j / size | 0) * stride + littleOffset;
      var index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
var byteSizeMap$1 = {5126: 4, 5123: 2, 5121: 1};
var UID$3 = 0;
var map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry = function() {
  function Geometry2(buffers, attributes) {
    if (buffers === void 0) {
      buffers = [];
    }
    if (attributes === void 0) {
      attributes = {};
    }
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID$3++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new Runner("disposeGeometry");
    this.refCount = 0;
  }
  Geometry2.prototype.addAttribute = function(id, buffer, size, normalized, type, stride, start, instance) {
    if (size === void 0) {
      size = 0;
    }
    if (normalized === void 0) {
      normalized = false;
    }
    if (instance === void 0) {
      instance = false;
    }
    if (!buffer) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer instanceof Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Float32Array(buffer);
      }
      buffer = new Buffer(buffer);
    }
    var ids = id.split("|");
    if (ids.length > 1) {
      for (var i = 0; i < ids.length; i++) {
        this.addAttribute(ids[i], buffer, size, normalized, type);
      }
      return this;
    }
    var bufferIndex = this.buffers.indexOf(buffer);
    if (bufferIndex === -1) {
      this.buffers.push(buffer);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  };
  Geometry2.prototype.getAttribute = function(id) {
    return this.attributes[id];
  };
  Geometry2.prototype.getBuffer = function(id) {
    return this.buffers[this.getAttribute(id).buffer];
  };
  Geometry2.prototype.addIndex = function(buffer) {
    if (!(buffer instanceof Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Uint16Array(buffer);
      }
      buffer = new Buffer(buffer);
    }
    buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer;
    if (this.buffers.indexOf(buffer) === -1) {
      this.buffers.push(buffer);
    }
    return this;
  };
  Geometry2.prototype.getIndex = function() {
    return this.indexBuffer;
  };
  Geometry2.prototype.interleave = function() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
      return this;
    }
    var arrays = [];
    var sizes = [];
    var interleavedBuffer = new Buffer();
    var i;
    for (i in this.attributes) {
      var attribute = this.attributes[i];
      var buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data);
      sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
    for (i = 0; i < this.buffers.length; i++) {
      if (this.buffers[i] !== this.indexBuffer) {
        this.buffers[i].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  };
  Geometry2.prototype.getSize = function() {
    for (var i in this.attributes) {
      var attribute = this.attributes[i];
      var buffer = this.buffers[attribute.buffer];
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  };
  Geometry2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Geometry2.prototype.destroy = function() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  };
  Geometry2.prototype.clone = function() {
    var geometry = new Geometry2();
    for (var i = 0; i < this.buffers.length; i++) {
      geometry.buffers[i] = new Buffer(this.buffers[i].data.slice(0));
    }
    for (var i in this.attributes) {
      var attrib = this.attributes[i];
      geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  };
  Geometry2.merge = function(geometries) {
    var geometryOut = new Geometry2();
    var arrays = [];
    var sizes = [];
    var offsets = [];
    var geometry;
    for (var i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (var j = 0; j < geometry.buffers.length; j++) {
        sizes[j] = sizes[j] || 0;
        sizes[j] += geometry.buffers[j].data.length;
        offsets[j] = 0;
      }
    }
    for (var i = 0; i < geometry.buffers.length; i++) {
      arrays[i] = new map[getBufferType(geometry.buffers[i].data)](sizes[i]);
      geometryOut.buffers[i] = new Buffer(arrays[i]);
    }
    for (var i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (var j = 0; j < geometry.buffers.length; j++) {
        arrays[j].set(geometry.buffers[j].data, offsets[j]);
        offsets[j] += geometry.buffers[j].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      var offset = 0;
      var stride = 0;
      var offset2 = 0;
      var bufferIndexToCount = 0;
      for (var i = 0; i < geometry.buffers.length; i++) {
        if (geometry.buffers[i] !== geometry.indexBuffer) {
          bufferIndexToCount = i;
          break;
        }
      }
      for (var i in geometry.attributes) {
        var attribute = geometry.attributes[i];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap$1[attribute.type] / 4;
        }
      }
      for (var i = 0; i < geometries.length; i++) {
        var indexBufferData = geometries[i].indexBuffer.data;
        for (var j = 0; j < indexBufferData.length; j++) {
          geometryOut.indexBuffer.data[j + offset2] += offset;
        }
        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  };
  return Geometry2;
}();
var Quad = function(_super) {
  __extends(Quad2, _super);
  function Quad2() {
    var _this = _super.call(this) || this;
    _this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
    return _this;
  }
  return Quad2;
}(Geometry);
var QuadUv = function(_super) {
  __extends(QuadUv2, _super);
  function QuadUv2() {
    var _this = _super.call(this) || this;
    _this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    _this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    _this.vertexBuffer = new Buffer(_this.vertices);
    _this.uvBuffer = new Buffer(_this.uvs);
    _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
    return _this;
  }
  QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
    var x = 0;
    var y = 0;
    this.uvs[0] = x;
    this.uvs[1] = y;
    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y;
    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x;
    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
    x = destinationFrame.x;
    y = destinationFrame.y;
    this.vertices[0] = x;
    this.vertices[1] = y;
    this.vertices[2] = x + destinationFrame.width;
    this.vertices[3] = y;
    this.vertices[4] = x + destinationFrame.width;
    this.vertices[5] = y + destinationFrame.height;
    this.vertices[6] = x;
    this.vertices[7] = y + destinationFrame.height;
    this.invalidate();
    return this;
  };
  QuadUv2.prototype.invalidate = function() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  };
  return QuadUv2;
}(Geometry);
var UID$2 = 0;
var UniformGroup = function() {
  function UniformGroup2(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID$2++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer) {
      this.buffer = uniforms;
      this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer(new Float32Array(1));
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  UniformGroup2.prototype.update = function() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  };
  UniformGroup2.prototype.add = function(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup2(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  };
  UniformGroup2.from = function(uniforms, _static, _ubo) {
    return new UniformGroup2(uniforms, _static, _ubo);
  };
  UniformGroup2.uboFrom = function(uniforms, _static) {
    return new UniformGroup2(uniforms, _static !== null && _static !== void 0 ? _static : true, true);
  };
  return UniformGroup2;
}();
var FilterState = function() {
  function FilterState2() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = MSAA_QUALITY.NONE;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.bindingSourceFrame = new Rectangle();
    this.bindingDestinationFrame = new Rectangle();
    this.filters = [];
    this.transform = null;
  }
  FilterState2.prototype.clear = function() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  };
  return FilterState2;
}();
var tempPoints = [new Point(), new Point(), new Point(), new Point()];
var tempMatrix$2 = new Matrix();
var FilterSystem = function() {
  function FilterSystem2(renderer) {
    this.renderer = renderer;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool();
    this.texturePool.setScreenSize(renderer.view);
    this.statePool = [];
    this.quad = new Quad();
    this.quadUv = new QuadUv();
    this.tempRect = new Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  FilterSystem2.prototype.push = function(target, filters) {
    var _a, _b;
    var renderer = this.renderer;
    var filterStack = this.defaultFilterStack;
    var state = this.statePool.pop() || new FilterState();
    var renderTextureSystem = this.renderer.renderTexture;
    var resolution = filters[0].resolution;
    var multisample = filters[0].multisample;
    var padding = filters[0].padding;
    var autoFit = filters[0].autoFit;
    var legacy = (_a = filters[0].legacy) !== null && _a !== void 0 ? _a : true;
    for (var i = 1; i < filters.length; i++) {
      var filter = filters[i];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || ((_b = filter.legacy) !== null && _b !== void 0 ? _b : true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer.projection.transform) {
      this.transformAABB(tempMatrix$2.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    var destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer.projection.transform;
    renderer.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer.framebuffer.clear(0, 0, 0, 0);
  };
  FilterSystem2.prototype.pop = function() {
    var filterStack = this.defaultFilterStack;
    var state = filterStack.pop();
    var filters = state.filters;
    this.activeState = state;
    var globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    var inputSize = globalUniforms.inputSize;
    var inputPixel = globalUniforms.inputPixel;
    var inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      var filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    var lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      var flip = state.renderTexture;
      var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      var i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        if (i === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
        var t = flip;
        flip = flop;
        flop = t;
      }
      filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      if (i > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  };
  FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
    if (clearMode === void 0) {
      clearMode = CLEAR_MODES.CLEAR;
    }
    var _a = this.renderer, renderTextureSystem = _a.renderTexture, stateSystem = _a.state;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture && filterTexture.filterFrame) {
      var destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    var autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  };
  FilterSystem2.prototype.applyFilter = function(filter, input, output, clearMode) {
    var renderer = this.renderer;
    renderer.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer.geometry.bind(this.quadUv);
      renderer.geometry.draw(DRAW_MODES.TRIANGLES);
    } else {
      renderer.geometry.bind(this.quad);
      renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
    }
  };
  FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
    var _a = this.activeState, sourceFrame = _a.sourceFrame, destinationFrame = _a.destinationFrame;
    var orig = sprite._texture.orig;
    var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  };
  FilterSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.texturePool.clear(false);
  };
  FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (multisample === void 0) {
      multisample = MSAA_QUALITY.NONE;
    }
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  };
  FilterSystem2.prototype.getFilterTexture = function(input, resolution, multisample) {
    if (typeof input === "number") {
      var swap = input;
      input = resolution;
      resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  };
  FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  };
  FilterSystem2.prototype.emptyPool = function() {
    this.texturePool.clear(true);
  };
  FilterSystem2.prototype.resize = function() {
    this.texturePool.setScreenSize(this.renderer.view);
  };
  FilterSystem2.prototype.transformAABB = function(matrix, rect) {
    var lt = tempPoints[0];
    var lb = tempPoints[1];
    var rt = tempPoints[2];
    var rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  };
  FilterSystem2.prototype.roundFrame = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      var a = transform.a, b = transform.b, c = transform.c, d = transform.d;
      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  };
  return FilterSystem2;
}();
var ObjectRenderer = function() {
  function ObjectRenderer2(renderer) {
    this.renderer = renderer;
  }
  ObjectRenderer2.prototype.flush = function() {
  };
  ObjectRenderer2.prototype.destroy = function() {
    this.renderer = null;
  };
  ObjectRenderer2.prototype.start = function() {
  };
  ObjectRenderer2.prototype.stop = function() {
    this.flush();
  };
  ObjectRenderer2.prototype.render = function(_object) {
  };
  return ObjectRenderer2;
}();
var BatchSystem = function() {
  function BatchSystem2(renderer) {
    this.renderer = renderer;
    this.emptyRenderer = new ObjectRenderer(renderer);
    this.currentRenderer = this.emptyRenderer;
  }
  BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  };
  BatchSystem2.prototype.flush = function() {
    this.setObjectRenderer(this.emptyRenderer);
  };
  BatchSystem2.prototype.reset = function() {
    this.setObjectRenderer(this.emptyRenderer);
  };
  BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
    var boundTextures = this.renderer.texture.boundTextures;
    for (var i = maxTextures - 1; i >= 0; --i) {
      arr[i] = boundTextures[i] || null;
      if (arr[i]) {
        arr[i]._batchLocation = i;
      }
    }
  };
  BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
    var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
    var j = 0;
    for (var i = 0; i < count; i++) {
      var tex = elements[i];
      var loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i] = loc;
        continue;
      }
      while (j < maxTextures) {
        var bound = boundTextures[j];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
          j++;
          continue;
        }
        ids[i] = j;
        tex._batchLocation = j;
        boundTextures[j] = tex;
        break;
      }
    }
  };
  BatchSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return BatchSystem2;
}();
var CONTEXT_UID_COUNTER = 0;
var ContextSystem = function() {
  function ContextSystem2(renderer) {
    this.renderer = renderer;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
    renderer.view.addEventListener("webglcontextlost", this.handleContextLost, false);
    renderer.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
  }
  Object.defineProperty(ContextSystem2.prototype, "isLost", {
    get: function() {
      return !this.gl || this.gl.isContextLost();
    },
    enumerable: false,
    configurable: true
  });
  ContextSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
      gl.getExtension("WEBGL_lose_context").restoreContext();
    }
  };
  ContextSystem2.prototype.initFromContext = function(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
  };
  ContextSystem2.prototype.initFromOptions = function(options) {
    var gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  };
  ContextSystem2.prototype.createContext = function(canvas, options) {
    var gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  };
  ContextSystem2.prototype.getExtensions = function() {
    var gl = this.gl;
    var common = {
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        loseContext: gl.getExtension("WEBGL_lose_context"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  };
  ContextSystem2.prototype.handleContextLost = function(event) {
    event.preventDefault();
  };
  ContextSystem2.prototype.handleContextRestored = function() {
    this.renderer.runners.contextChange.emit(this.gl);
  };
  ContextSystem2.prototype.destroy = function() {
    var view = this.renderer.view;
    this.renderer = null;
    view.removeEventListener("webglcontextlost", this.handleContextLost);
    view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  };
  ContextSystem2.prototype.postrender = function() {
    if (this.renderer.renderingToScreen) {
      this.gl.flush();
    }
  };
  ContextSystem2.prototype.validateContext = function(gl) {
    var attributes = gl.getContextAttributes();
    var isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  };
  return ContextSystem2;
}();
var GLFramebuffer = function() {
  function GLFramebuffer2(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
  return GLFramebuffer2;
}();
var tempRectangle = new Rectangle();
var FramebufferSystem = function() {
  function FramebufferSystem2(renderer) {
    this.renderer = renderer;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  FramebufferSystem2.prototype.contextChange = function() {
    var gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    this.disposeAll(true);
    if (this.renderer.context.webGLVersion === 1) {
      var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
      var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension_1 = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension_1) {
        gl.drawBuffers = function(activeTextures) {
          return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
        };
      } else {
        this.hasMRT = false;
        gl.drawBuffers = function() {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  };
  FramebufferSystem2.prototype.bind = function(framebuffer, frame, mipLevel) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    var gl = this.gl;
    if (framebuffer) {
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (var i = 0; i < framebuffer.colorTextures.length; i++) {
        var tex = framebuffer.colorTextures[i];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        var mipWidth = frame.width >> mipLevel;
        var mipHeight = frame.height >> mipLevel;
        var scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        var mipWidth = framebuffer.width >> mipLevel;
        var mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  };
  FramebufferSystem2.prototype.setViewport = function(x, y, width, height) {
    var v = this.viewport;
    x = Math.round(x);
    y = Math.round(y);
    width = Math.round(width);
    height = Math.round(height);
    if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
      v.x = x;
      v.y = y;
      v.width = width;
      v.height = height;
      this.gl.viewport(x, y, width, height);
    }
  };
  Object.defineProperty(FramebufferSystem2.prototype, "size", {
    get: function() {
      if (this.current) {
        return {x: 0, y: 0, width: this.current.width, height: this.current.height};
      }
      return {x: 0, y: 0, width: this.renderer.width, height: this.renderer.height};
    },
    enumerable: false,
    configurable: true
  });
  FramebufferSystem2.prototype.clear = function(r, g, b, a, mask) {
    if (mask === void 0) {
      mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH;
    }
    var gl = this.gl;
    gl.clearColor(r, g, b, a);
    gl.clear(mask);
  };
  FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
    var gl = this.gl;
    var fbo = new GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  };
  FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
    var gl = this.gl;
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.msaaBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
    }
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    var colorTextures = framebuffer.colorTextures;
    var count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (var i = 0; i < count; i++) {
      var texture = colorTextures[i];
      var parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  };
  FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer, mipLevel) {
    var gl = this.gl;
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    var colorTextures = framebuffer.colorTextures;
    var count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    var activeTextures = [];
    for (var i = 0; i < count; i++) {
      var texture = colorTextures[i];
      var parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        continue;
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      var writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        var depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  };
  FramebufferSystem2.prototype.canMultisampleFramebuffer = function(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  };
  FramebufferSystem2.prototype.detectSamples = function(samples) {
    var msaaSamples = this.msaaSamples;
    var res = MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (var i = 0; i < msaaSamples.length; i++) {
      if (msaaSamples[i] <= samples) {
        res = msaaSamples[i];
        break;
      }
    }
    if (res === 1) {
      res = MSAA_QUALITY.NONE;
    }
    return res;
  };
  FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
    var _a = this, current = _a.current, renderer = _a.renderer, gl = _a.gl, CONTEXT_UID = _a.CONTEXT_UID;
    if (renderer.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    var fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      var colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
  };
  FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    var gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    var index = this.managedFramebuffers.indexOf(framebuffer);
    if (index >= 0) {
      this.managedFramebuffers.splice(index, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      fbo.blitFramebuffer.dispose();
    }
  };
  FramebufferSystem2.prototype.disposeAll = function(contextLost) {
    var list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (var i = 0; i < list.length; i++) {
      this.disposeFramebuffer(list[i], contextLost);
    }
  };
  FramebufferSystem2.prototype.forceStencil = function() {
    var framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    var w = framebuffer.width;
    var h = framebuffer.height;
    var gl = this.gl;
    var stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  };
  FramebufferSystem2.prototype.reset = function() {
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
  };
  FramebufferSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return FramebufferSystem2;
}();
var byteSizeMap = {5126: 4, 5123: 2, 5121: 1};
var GeometrySystem = function() {
  function GeometrySystem2(renderer) {
    this.renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  GeometrySystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    var gl = this.gl = this.renderer.gl;
    var context2 = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context2.webGLVersion !== 2) {
      var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeVaoExtension_1 = null;
      }
      if (nativeVaoExtension_1) {
        gl.createVertexArray = function() {
          return nativeVaoExtension_1.createVertexArrayOES();
        };
        gl.bindVertexArray = function(vao) {
          return nativeVaoExtension_1.bindVertexArrayOES(vao);
        };
        gl.deleteVertexArray = function(vao) {
          return nativeVaoExtension_1.deleteVertexArrayOES(vao);
        };
      } else {
        this.hasVao = false;
        gl.createVertexArray = function() {
          return null;
        };
        gl.bindVertexArray = function() {
          return null;
        };
        gl.deleteVertexArray = function() {
          return null;
        };
      }
    }
    if (context2.webGLVersion !== 2) {
      var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt_1) {
        gl.vertexAttribDivisor = function(a, b) {
          return instanceExt_1.vertexAttribDivisorANGLE(a, b);
        };
        gl.drawElementsInstanced = function(a, b, c, d, e) {
          return instanceExt_1.drawElementsInstancedANGLE(a, b, c, d, e);
        };
        gl.drawArraysInstanced = function(a, b, c, d) {
          return instanceExt_1.drawArraysInstancedANGLE(a, b, c, d);
        };
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
  };
  GeometrySystem2.prototype.bind = function(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    var gl = this.gl;
    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  };
  GeometrySystem2.prototype.reset = function() {
    this.unbind();
  };
  GeometrySystem2.prototype.updateBuffers = function() {
    var geometry = this._activeGeometry;
    var bufferSystem = this.renderer.buffer;
    for (var i = 0; i < geometry.buffers.length; i++) {
      var buffer = geometry.buffers[i];
      bufferSystem.update(buffer);
    }
  };
  GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
    var geometryAttributes = geometry.attributes;
    var shaderAttributes = program.attributeData;
    for (var j in shaderAttributes) {
      if (!geometryAttributes[j]) {
        throw new Error('shader and geometry incompatible, geometry missing the "' + j + '" attribute');
      }
    }
  };
  GeometrySystem2.prototype.getSignature = function(geometry, program) {
    var attribs = geometry.attributes;
    var shaderAttributes = program.attributeData;
    var strings = ["g", geometry.id];
    for (var i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  };
  GeometrySystem2.prototype.initGeometryVao = function(geometry, shader, incRefCount) {
    if (incRefCount === void 0) {
      incRefCount = true;
    }
    var gl = this.gl;
    var CONTEXT_UID = this.CONTEXT_UID;
    var bufferSystem = this.renderer.buffer;
    var program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    var signature = this.getSignature(geometry, program);
    var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    var buffers = geometry.buffers;
    var attributes = geometry.attributes;
    var tempStride = {};
    var tempStart = {};
    for (var j in buffers) {
      tempStride[j] = 0;
      tempStart[j] = 0;
    }
    for (var j in attributes) {
      if (!attributes[j].size && program.attributeData[j]) {
        attributes[j].size = program.attributeData[j].size;
      } else if (!attributes[j].size) {
        console.warn("PIXI Geometry attribute '" + j + "' size cannot be determined (likely the bound shader does not have the attribute)");
      }
      tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];
    }
    for (var j in attributes) {
      var attribute = attributes[j];
      var attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (var i = 0; i < buffers.length; i++) {
      var buffer = buffers[i];
      bufferSystem.bind(buffer);
      if (incRefCount) {
        buffer._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    this._activeVao = vao;
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    return vao;
  };
  GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
    var _a;
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var gl = this.gl;
    var buffers = geometry.buffers;
    var bufferSystem = (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (var i = 0; i < buffers.length; i++) {
        var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (var vaoId in vaos) {
        if (vaoId[0] === "g") {
          var vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  };
  GeometrySystem2.prototype.disposeAll = function(contextLost) {
    var all = Object.keys(this.managedGeometries);
    for (var i = 0; i < all.length; i++) {
      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
    }
  };
  GeometrySystem2.prototype.activateVao = function(geometry, program) {
    var gl = this.gl;
    var CONTEXT_UID = this.CONTEXT_UID;
    var bufferSystem = this.renderer.buffer;
    var buffers = geometry.buffers;
    var attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    var lastBuffer = null;
    for (var j in attributes) {
      var attribute = attributes[j];
      var buffer = buffers[attribute.buffer];
      var glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        var location = program.attributeData[j].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, 1);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  };
  GeometrySystem2.prototype.draw = function(type, size, start, instanceCount) {
    var gl = this.gl;
    var geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size || geometry.getSize());
    }
    return this;
  };
  GeometrySystem2.prototype.unbind = function() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  };
  GeometrySystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return GeometrySystem2;
}();
var MaskData = function() {
  function MaskData2(maskObject) {
    if (maskObject === void 0) {
      maskObject = null;
    }
    this.type = MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = settings.FILTER_MULTISAMPLE;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  Object.defineProperty(MaskData2.prototype, "filter", {
    get: function() {
      return this._filters ? this._filters[0] : null;
    },
    set: function(value) {
      if (value) {
        if (this._filters) {
          this._filters[0] = value;
        } else {
          this._filters = [value];
        }
      } else {
        this._filters = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  MaskData2.prototype.reset = function() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  };
  MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  };
  return MaskData2;
}();
function compileShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function logPrettyShaderError(gl, shader) {
  var shaderSrc = gl.getShaderSource(shader).split("\n").map(function(line, index) {
    return index + ": " + line;
  });
  var shaderLog = gl.getShaderInfoLog(shader);
  var splitShader = shaderLog.split("\n");
  var dedupe = {};
  var lineNumbers = splitShader.map(function(line) {
    return parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(n) {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  var logArgs = [""];
  lineNumbers.forEach(function(number) {
    shaderSrc[number - 1] = "%c" + shaderSrc[number - 1] + "%c";
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn.apply(console, logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
function booleanArray(size) {
  var array = new Array(size);
  for (var i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {};
var context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var canvas = settings.ADAPTER.createCanvas();
    var gl = void 0;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    var gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    var precision = requestedPrecision;
    if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
      precision = PRECISION.MEDIUM;
    }
    return "precision " + precision + " float;\n" + src;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
var GL_TABLE = null;
var GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var i = 0; i < typeNames.length; ++i) {
      var tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
var uniformParsers = [
  {
    test: function(data) {
      return data.type === "float" && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
    }
  },
  {
    test: function(data, uniform) {
      return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0);
    },
    code: function(name) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0;
    },
    code: function(name) {
      return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
    },
    codeUbo: function(name) {
      return "\n                var " + name + "_matrix = uv." + name + ".toArray(true);\n\n                data[offset] = " + name + "_matrix[0];\n                data[offset+1] = " + name + "_matrix[1];\n                data[offset+2] = " + name + "_matrix[2];\n        \n                data[offset + 4] = " + name + "_matrix[3];\n                data[offset + 5] = " + name + "_matrix[4];\n                data[offset + 6] = " + name + "_matrix[5];\n        \n                data[offset + 8] = " + name + "_matrix[6];\n                data[offset + 9] = " + name + "_matrix[7];\n                data[offset + 10] = " + name + "_matrix[8];\n            ";
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
    },
    codeUbo: function(name) {
      return "\n                v = uv." + name + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
    }
  },
  {
    test: function(data) {
      return data.type === "vec2" && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
    },
    codeUbo: function(name) {
      return "\n                    v = uv." + name + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
    }
  },
  {
    test: function(data) {
      return data.type === "vec4" && data.size === 1 && !data.isArray;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
    }
  }
];
var GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
  vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
  vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
  vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
  int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
  uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
  uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
  uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
  bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
  bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  samplerCube: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  sampler2DArray: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }"
};
var GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var _a;
  var funcFragments = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
  for (var i in group.uniforms) {
    var data = uniformData[i];
    if (!data) {
      if ((_a = group.uniforms[i]) === null || _a === void 0 ? void 0 : _a.group) {
        if (group.uniforms[i].ubo) {
          funcFragments.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i + ", '" + i + "');\n                    ");
        } else {
          funcFragments.push("\n                        renderer.shader.syncUniformGroup(uv." + i + ", syncData);\n                    ");
        }
      }
      continue;
    }
    var uniform = group.uniforms[i];
    var parsed = false;
    for (var j = 0; j < uniformParsers.length; j++) {
      if (uniformParsers[j].test(data, uniform)) {
        funcFragments.push(uniformParsers[j].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      var templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      var template = templateType[data.type].replace("location", 'ud["' + i + '"].location');
      funcFragments.push('\n            cu = ud["' + i + '"];\n            cv = cu.value;\n            v = uv["' + i + '"];\n            ' + template + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  var src = "";
  for (var i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += "if(test == " + i + ".0){}";
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  var shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({a: "b"}, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var defaultFragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
var UID$1 = 0;
var nameCache = {};
var Program = function() {
  function Program2(vertexSrc, fragmentSrc, name) {
    if (name === void 0) {
      name = "pixi-shader";
    }
    this.id = UID$1++;
    this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += "-" + nameCache[name];
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
      this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
      this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH);
      this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  Object.defineProperty(Program2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Program2, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$2;
    },
    enumerable: false,
    configurable: true
  });
  Program2.from = function(vertexSrc, fragmentSrc, name) {
    var key = vertexSrc + fragmentSrc;
    var program = ProgramCache[key];
    if (!program) {
      ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name);
    }
    return program;
  };
  return Program2;
}();
var Shader = function() {
  function Shader2(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup({});
    }
  }
  Shader2.prototype.checkUniformExists = function(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (var i in group.uniforms) {
      var uniform = group.uniforms[i];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  };
  Shader2.prototype.destroy = function() {
    this.uniformGroup = null;
  };
  Object.defineProperty(Shader2.prototype, "uniforms", {
    get: function() {
      return this.uniformGroup.uniforms;
    },
    enumerable: false,
    configurable: true
  });
  Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
    var program = Program.from(vertexSrc, fragmentSrc);
    return new Shader2(program, uniforms);
  };
  return Shader2;
}();
var BLEND$1 = 0;
var OFFSET$1 = 1;
var CULLING$1 = 2;
var DEPTH_TEST$1 = 3;
var WINDING$1 = 4;
var DEPTH_MASK$1 = 5;
var State = function() {
  function State2() {
    this.data = 0;
    this.blendMode = BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  Object.defineProperty(State2.prototype, "blend", {
    get: function() {
      return !!(this.data & 1 << BLEND$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << BLEND$1) !== value) {
        this.data ^= 1 << BLEND$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "offsets", {
    get: function() {
      return !!(this.data & 1 << OFFSET$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << OFFSET$1) !== value) {
        this.data ^= 1 << OFFSET$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "culling", {
    get: function() {
      return !!(this.data & 1 << CULLING$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << CULLING$1) !== value) {
        this.data ^= 1 << CULLING$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "depthTest", {
    get: function() {
      return !!(this.data & 1 << DEPTH_TEST$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << DEPTH_TEST$1) !== value) {
        this.data ^= 1 << DEPTH_TEST$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "depthMask", {
    get: function() {
      return !!(this.data & 1 << DEPTH_MASK$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << DEPTH_MASK$1) !== value) {
        this.data ^= 1 << DEPTH_MASK$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "clockwiseFrontFace", {
    get: function() {
      return !!(this.data & 1 << WINDING$1);
    },
    set: function(value) {
      if (!!(this.data & 1 << WINDING$1) !== value) {
        this.data ^= 1 << WINDING$1;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "blendMode", {
    get: function() {
      return this._blendMode;
    },
    set: function(value) {
      this.blend = value !== BLEND_MODES.NONE;
      this._blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "polygonOffset", {
    get: function() {
      return this._polygonOffset;
    },
    set: function(value) {
      this.offsets = !!value;
      this._polygonOffset = value;
    },
    enumerable: false,
    configurable: true
  });
  State2.prototype.toString = function() {
    return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
  };
  State2.for2d = function() {
    var state = new State2();
    state.depthTest = false;
    state.blend = true;
    return state;
  };
  return State2;
}();
var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var defaultVertex$2 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var Filter = function(_super) {
  __extends(Filter2, _super);
  function Filter2(vertexSrc, fragmentSrc, uniforms) {
    var _this = this;
    var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
    _this = _super.call(this, program, uniforms) || this;
    _this.padding = 0;
    _this.resolution = settings.FILTER_RESOLUTION;
    _this.multisample = settings.FILTER_MULTISAMPLE;
    _this.enabled = true;
    _this.autoFit = true;
    _this.state = new State();
    return _this;
  }
  Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  };
  Object.defineProperty(Filter2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._resolution = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$1;
    },
    enumerable: false,
    configurable: true
  });
  return Filter2;
}(Shader);
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var tempMat = new Matrix();
var TextureMatrix = function() {
  function TextureMatrix2(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  Object.defineProperty(TextureMatrix2.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(value) {
      this._texture = value;
      this._textureID = -1;
    },
    enumerable: false,
    configurable: true
  });
  TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    var mat = this.mapCoord;
    for (var i = 0; i < uvs.length; i += 2) {
      var x = uvs[i];
      var y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx;
      out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  };
  TextureMatrix2.prototype.update = function(forceUpdate) {
    var tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    var uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    var orig = tex.orig;
    var trim = tex.trim;
    if (trim) {
      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat);
    }
    var texBase = tex.baseTexture;
    var frame = this.uClampFrame;
    var margin = this.clampMargin / texBase.resolution;
    var offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  };
  return TextureMatrix2;
}();
var SpriteMaskFilter = function(_super) {
  __extends(SpriteMaskFilter2, _super);
  function SpriteMaskFilter2(vertexSrc, fragmentSrc, uniforms) {
    var _this = this;
    var sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    _this = _super.call(this, vertexSrc || vertex, fragmentSrc || fragment, uniforms) || this;
    _this.maskSprite = sprite;
    _this.maskMatrix = new Matrix();
    return _this;
  }
  Object.defineProperty(SpriteMaskFilter2.prototype, "maskSprite", {
    get: function() {
      return this._maskSprite;
    },
    set: function(value) {
      this._maskSprite = value;
      if (this._maskSprite) {
        this._maskSprite.renderable = false;
      }
    },
    enumerable: false,
    configurable: true
  });
  SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
    var maskSprite = this._maskSprite;
    var tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  };
  return SpriteMaskFilter2;
}(Filter);
var MaskSystem = function() {
  function MaskSystem2(renderer) {
    this.renderer = renderer;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  MaskSystem2.prototype.setMaskStack = function(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  };
  MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
    var maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      var d = this.maskDataPool.pop() || new MaskData();
      d.pooled = true;
      d.maskObject = maskDataOrTarget;
      maskData = d;
    }
    var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
      }
    }
    if (maskData.type === MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  };
  MaskSystem2.prototype.pop = function(target) {
    var maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      var maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  };
  MaskSystem2.prototype.detect = function(maskData) {
    var maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = MASK_TYPES.SCISSOR;
    } else {
      maskData.type = MASK_TYPES.STENCIL;
    }
  };
  MaskSystem2.prototype.pushSpriteMask = function(maskData) {
    var _a, _b;
    var maskObject = maskData.maskObject;
    var target = maskData._target;
    var alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
      }
    }
    var renderer = this.renderer;
    var renderTextureSystem = renderer.renderTexture;
    var resolution;
    var multisample;
    if (renderTextureSystem.current) {
      var renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = (_a = maskData.multisample) !== null && _a !== void 0 ? _a : renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer.resolution;
      multisample = (_b = maskData.multisample) !== null && _b !== void 0 ? _b : renderer.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    var stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  };
  MaskSystem2.prototype.popSpriteMask = function(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  };
  MaskSystem2.prototype.pushColorMask = function(maskData) {
    var currColorMask = maskData._colorMask;
    var nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  };
  MaskSystem2.prototype.popColorMask = function(maskData) {
    var currColorMask = maskData._colorMask;
    var nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  };
  MaskSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return MaskSystem2;
}();
var AbstractMaskSystem = function() {
  function AbstractMaskSystem2(renderer) {
    this.renderer = renderer;
    this.maskStack = [];
    this.glConst = 0;
  }
  AbstractMaskSystem2.prototype.getStackLength = function() {
    return this.maskStack.length;
  };
  AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
    var gl = this.renderer.gl;
    var curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    var newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  };
  AbstractMaskSystem2.prototype._useCurrent = function() {
  };
  AbstractMaskSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.maskStack = null;
  };
  return AbstractMaskSystem2;
}();
var tempMatrix$1 = new Matrix();
var rectPool = [];
var ScissorSystem = function(_super) {
  __extends(ScissorSystem2, _super);
  function ScissorSystem2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
    return _this;
  }
  ScissorSystem2.prototype.getStackLength = function() {
    var maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  };
  ScissorSystem2.prototype.calcScissorRect = function(maskData) {
    var _a;
    if (maskData._scissorRectLocal) {
      return;
    }
    var prevData = maskData._scissorRect;
    var maskObject = maskData.maskObject;
    var renderer = this.renderer;
    var renderTextureSystem = renderer.renderTexture;
    var rect = maskObject.getBounds(true, (_a = rectPool.pop()) !== null && _a !== void 0 ? _a : new Rectangle());
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  };
  ScissorSystem2.isMatrixRotated = function(matrix) {
    if (!matrix) {
      return false;
    }
    var a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d;
    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
  };
  ScissorSystem2.prototype.testScissor = function(maskData) {
    var maskObject = maskData.maskObject;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (ScissorSystem2.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (ScissorSystem2.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    var rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  };
  ScissorSystem2.prototype.roundFrameToPixels = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (ScissorSystem2.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  };
  ScissorSystem2.prototype.push = function(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    var gl = this.renderer.gl;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  };
  ScissorSystem2.prototype.pop = function(maskData) {
    var gl = this.renderer.gl;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  };
  ScissorSystem2.prototype._useCurrent = function() {
    var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    var y;
    if (this.renderer.renderTexture.current) {
      y = rect.y;
    } else {
      y = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
  };
  return ScissorSystem2;
}(AbstractMaskSystem);
var StencilSystem = function(_super) {
  __extends(StencilSystem2, _super);
  function StencilSystem2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
    return _this;
  }
  StencilSystem2.prototype.getStackLength = function() {
    var maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  };
  StencilSystem2.prototype.push = function(maskData) {
    var maskObject = maskData.maskObject;
    var gl = this.renderer.gl;
    var prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    var colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  };
  StencilSystem2.prototype.pop = function(maskObject) {
    var gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      var maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      var colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  };
  StencilSystem2.prototype._useCurrent = function() {
    var gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  };
  return StencilSystem2;
}(AbstractMaskSystem);
var ProjectionSystem = function() {
  function ProjectionSystem2(renderer) {
    this.renderer = renderer;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new Matrix();
    this.transform = null;
  }
  ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    var renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer.globalUniforms.update();
    if (renderer.shader.shader) {
      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
    }
  };
  ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {
    var pm = this.projectionMatrix;
    var sign = !root ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign - sourceFrame.y * pm.d;
  };
  ProjectionSystem2.prototype.setTransform = function(_matrix) {
  };
  ProjectionSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return ProjectionSystem2;
}();
var tempRect = new Rectangle();
var tempRect2 = new Rectangle();
var RenderTextureSystem = function() {
  function RenderTextureSystem2(renderer) {
    this.renderer = renderer;
    this.clearColor = renderer._backgroundColorRgba;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.viewportFrame = new Rectangle();
  }
  RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
    if (renderTexture === void 0) {
      renderTexture = null;
    }
    var renderer = this.renderer;
    this.current = renderTexture;
    var baseTexture;
    var framebuffer;
    var resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer.screen.width;
        tempRect.height = renderer.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    var viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  };
  RenderTextureSystem2.prototype.clear = function(clearColor, mask) {
    if (this.current) {
      clearColor = clearColor || this.current.baseTexture.clearColor;
    } else {
      clearColor = clearColor || this.clearColor;
    }
    var destinationFrame = this.destinationFrame;
    var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
    var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      var _a = this.viewportFrame, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x, y, width, height);
    }
    this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  };
  RenderTextureSystem2.prototype.resize = function() {
    this.bind(null);
  };
  RenderTextureSystem2.prototype.reset = function() {
    this.bind(null);
  };
  RenderTextureSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return RenderTextureSystem2;
}();
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
var UBO_TO_SINGLE_SETTERS = {
  float: "\n        data[offset] = v;\n    ",
  vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
  vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
  vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
  mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
  mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
  mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
};
var GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  var uboElements = uniformData.map(function(data) {
    return {
      data,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  });
  var size = 0;
  var chunkSize = 0;
  var offset = 0;
  for (var i = 0; i < uboElements.length; i++) {
    var uboElement = uboElements[i];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      var lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return {uboElements, size: offset};
}
function getUBOData(uniforms, uniformData) {
  var usedUniformDatas = [];
  for (var i in uniforms) {
    if (uniformData[i]) {
      usedUniformDatas.push(uniformData[i]);
    }
  }
  usedUniformDatas.sort(function(a, b) {
    return a.index - b.index;
  });
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return {size: 0, syncFunc: uboUpdate};
  }
  var usedUniformDatas = getUBOData(group.uniforms, uniformData);
  var _a = createUBOElements(usedUniformDatas), uboElements = _a.uboElements, size = _a.size;
  var funcFragments = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
  for (var i = 0; i < uboElements.length; i++) {
    var uboElement = uboElements[i];
    var uniform = group.uniforms[uboElement.data.name];
    var name = uboElement.data.name;
    var parsed = false;
    for (var j = 0; j < uniformParsers.length; j++) {
      var uniformParser = uniformParsers[j];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push("offset = " + uboElement.offset / 4 + ";", uniformParsers[j].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        var size_1 = mapSize(uboElement.data.type);
        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        var elementSize = size_1 / rowSize;
        var remainder = (4 - elementSize % 4) % 4;
        funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + uboElement.data.size * rowSize + "; i++)\n                {\n                    for(var j = 0; j < " + elementSize + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + remainder + ";\n                }\n\n                ");
      } else {
        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n                " + template + ";\n                ");
      }
    }
  }
  funcFragments.push("\n       renderer.buffer.update(buffer);\n    ");
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}
var IGLUniformData = function() {
  function IGLUniformData2() {
  }
  return IGLUniformData2;
}();
var GLProgram = function() {
  function GLProgram2(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  GLProgram2.prototype.destroy = function() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  };
  return GLProgram2;
}();
function getAttributeData(program, gl) {
  var attributes = {};
  var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < totalAttributes; i++) {
    var attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.indexOf("gl_") === 0) {
      continue;
    }
    var type = mapType(gl, attribData.type);
    var data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
function getUniformData(program, gl) {
  var uniforms = {};
  var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i = 0; i < totalUniforms; i++) {
    var uniformData = gl.getActiveUniform(program, i);
    var name = uniformData.name.replace(/\[.*?\]$/, "");
    var isArray = !!uniformData.name.match(/\[.*?\]$/);
    var type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl, program) {
  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  var webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    var keys = Object.keys(program.attributeData);
    keys.sort(function(a, b) {
      return a > b ? 1 : -1;
    });
    for (var i = 0; i < keys.length; i++) {
      program.attributeData[keys[i]].location = i;
      gl.bindAttribLocation(webGLProgram, i, keys[i]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  var uniformData = {};
  for (var i in program.uniformData) {
    var data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue(data.type, data.size)
    };
  }
  var glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}
var UID = 0;
var defaultSyncData = {textureCount: 0, uboCount: 0};
var ShaderSystem = function() {
  function ShaderSystem2(renderer) {
    this.destroyed = false;
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID++;
  }
  ShaderSystem2.prototype.systemCheck = function() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  };
  ShaderSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.reset();
  };
  ShaderSystem2.prototype.bind = function(shader, dontSync) {
    shader.uniforms.globals = this.renderer.globalUniforms;
    var program = shader.program;
    var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  };
  ShaderSystem2.prototype.setUniforms = function(uniforms) {
    var shader = this.shader.program;
    var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  };
  ShaderSystem2.prototype.syncUniformGroup = function(group, syncData) {
    var glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  };
  ShaderSystem2.prototype.syncUniforms = function(group, glProgram, syncData) {
    var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  };
  ShaderSystem2.prototype.createSyncGroups = function(group) {
    var id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  };
  ShaderSystem2.prototype.syncUniformBufferGroup = function(group, name) {
    var glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  };
  ShaderSystem2.prototype.createSyncBufferGroup = function(group, glProgram, name) {
    var gl = this.renderer.gl;
    this.renderer.buffer.bind(group.buffer);
    var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    var id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    var uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      var data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  };
  ShaderSystem2.prototype.getSignature = function(group, uniformData, preFix) {
    var uniforms = group.uniforms;
    var strings = [preFix + "-"];
    for (var i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  };
  ShaderSystem2.prototype.getGlProgram = function() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  };
  ShaderSystem2.prototype.generateProgram = function(shader) {
    var gl = this.gl;
    var program = shader.program;
    var glProgram = generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  };
  ShaderSystem2.prototype.reset = function() {
    this.program = null;
    this.shader = null;
  };
  ShaderSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.destroyed = true;
  };
  return ShaderSystem2;
}();
function mapWebGLBlendModesToPixi(gl, array) {
  if (array === void 0) {
    array = [];
  }
  array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.NONE] = [0, 0];
  array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}
var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;
var DEPTH_MASK = 5;
var StateSystem = function() {
  function StateSystem2() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State();
    this.defaultState.blend = true;
  }
  StateSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  };
  StateSystem2.prototype.set = function(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      var diff = this.stateId ^ state.data;
      var i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff = diff >> 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (var i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  };
  StateSystem2.prototype.forceState = function(state) {
    state = state || this.defaultState;
    for (var i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (var i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  };
  StateSystem2.prototype.setBlend = function(value) {
    this.updateCheck(StateSystem2.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  };
  StateSystem2.prototype.setOffset = function(value) {
    this.updateCheck(StateSystem2.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  };
  StateSystem2.prototype.setDepthTest = function(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  };
  StateSystem2.prototype.setDepthMask = function(value) {
    this.gl.depthMask(value);
  };
  StateSystem2.prototype.setCullFace = function(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  };
  StateSystem2.prototype.setFrontFace = function(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  };
  StateSystem2.prototype.setBlendMode = function(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    var mode = this.blendModes[value];
    var gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  };
  StateSystem2.prototype.setPolygonOffset = function(value, scale) {
    this.gl.polygonOffset(value, scale);
  };
  StateSystem2.prototype.reset = function() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  };
  StateSystem2.prototype.updateCheck = function(func, value) {
    var index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  };
  StateSystem2.checkBlendMode = function(system, state) {
    system.setBlendMode(state.blendMode);
  };
  StateSystem2.checkPolygonOffset = function(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  };
  StateSystem2.prototype.destroy = function() {
    this.gl = null;
  };
  return StateSystem2;
}();
var TextureGCSystem = function() {
  function TextureGCSystem2(renderer) {
    this.renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = settings.GC_MAX_IDLE;
    this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
    this.mode = settings.GC_MODE;
  }
  TextureGCSystem2.prototype.postrender = function() {
    if (!this.renderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  };
  TextureGCSystem2.prototype.run = function() {
    var tm = this.renderer.texture;
    var managedTextures = tm.managedTextures;
    var wasRemoved = false;
    for (var i = 0; i < managedTextures.length; i++) {
      var texture = managedTextures[i];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      var j = 0;
      for (var i = 0; i < managedTextures.length; i++) {
        if (managedTextures[i] !== null) {
          managedTextures[j++] = managedTextures[i];
        }
      }
      managedTextures.length = j;
    }
  };
  TextureGCSystem2.prototype.unload = function(displayObject) {
    var tm = this.renderer.texture;
    var texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (var i = displayObject.children.length - 1; i >= 0; i--) {
      this.unload(displayObject.children[i]);
    }
  };
  TextureGCSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return TextureGCSystem2;
}();
function mapTypeAndFormatToInternalFormat(gl) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
  var table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = (_a = {}, _a[TYPES.UNSIGNED_BYTE] = (_b = {}, _b[FORMATS.RGBA] = gl.RGBA8, _b[FORMATS.RGB] = gl.RGB8, _b[FORMATS.RG] = gl.RG8, _b[FORMATS.RED] = gl.R8, _b[FORMATS.RGBA_INTEGER] = gl.RGBA8UI, _b[FORMATS.RGB_INTEGER] = gl.RGB8UI, _b[FORMATS.RG_INTEGER] = gl.RG8UI, _b[FORMATS.RED_INTEGER] = gl.R8UI, _b[FORMATS.ALPHA] = gl.ALPHA, _b[FORMATS.LUMINANCE] = gl.LUMINANCE, _b[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b), _a[TYPES.BYTE] = (_c = {}, _c[FORMATS.RGBA] = gl.RGBA8_SNORM, _c[FORMATS.RGB] = gl.RGB8_SNORM, _c[FORMATS.RG] = gl.RG8_SNORM, _c[FORMATS.RED] = gl.R8_SNORM, _c[FORMATS.RGBA_INTEGER] = gl.RGBA8I, _c[FORMATS.RGB_INTEGER] = gl.RGB8I, _c[FORMATS.RG_INTEGER] = gl.RG8I, _c[FORMATS.RED_INTEGER] = gl.R8I, _c), _a[TYPES.UNSIGNED_SHORT] = (_d = {}, _d[FORMATS.RGBA_INTEGER] = gl.RGBA16UI, _d[FORMATS.RGB_INTEGER] = gl.RGB16UI, _d[FORMATS.RG_INTEGER] = gl.RG16UI, _d[FORMATS.RED_INTEGER] = gl.R16UI, _d[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d), _a[TYPES.SHORT] = (_e = {}, _e[FORMATS.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS.RGB_INTEGER] = gl.RGB16I, _e[FORMATS.RG_INTEGER] = gl.RG16I, _e[FORMATS.RED_INTEGER] = gl.R16I, _e), _a[TYPES.UNSIGNED_INT] = (_f = {}, _f[FORMATS.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS.RG_INTEGER] = gl.RG32UI, _f[FORMATS.RED_INTEGER] = gl.R32UI, _f[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a[TYPES.INT] = (_g = {}, _g[FORMATS.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS.RGB_INTEGER] = gl.RGB32I, _g[FORMATS.RG_INTEGER] = gl.RG32I, _g[FORMATS.RED_INTEGER] = gl.R32I, _g), _a[TYPES.FLOAT] = (_h = {}, _h[FORMATS.RGBA] = gl.RGBA32F, _h[FORMATS.RGB] = gl.RGB32F, _h[FORMATS.RG] = gl.RG32F, _h[FORMATS.RED] = gl.R32F, _h[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a[TYPES.HALF_FLOAT] = (_j = {}, _j[FORMATS.RGBA] = gl.RGBA16F, _j[FORMATS.RGB] = gl.RGB16F, _j[FORMATS.RG] = gl.RG16F, _j[FORMATS.RED] = gl.R16F, _j), _a[TYPES.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS.RGB] = gl.RGB565, _k), _a[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_l = {}, _l[FORMATS.RGBA] = gl.RGBA4, _l), _a[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS.RGBA] = gl.RGB5_A1, _m), _a[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS.RGBA] = gl.RGB10_A2, _o[FORMATS.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (_p = {}, _p[FORMATS.RGB] = gl.R11F_G11F_B10F, _p), _a[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS.RGB] = gl.RGB9_E5, _q), _a[TYPES.UNSIGNED_INT_24_8] = (_r = {}, _r[FORMATS.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r), _a[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a);
  } else {
    table = (_t = {}, _t[TYPES.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS.RGBA] = gl.RGBA, _u[FORMATS.RGB] = gl.RGB, _u[FORMATS.ALPHA] = gl.ALPHA, _u[FORMATS.LUMINANCE] = gl.LUMINANCE, _u[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS.RGB] = gl.RGB, _v), _t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS.RGBA] = gl.RGBA, _w), _t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS.RGBA] = gl.RGBA, _x), _t);
  }
  return table;
}
var GLTexture = function() {
  function GLTexture2(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = TYPES.UNSIGNED_BYTE;
    this.internalFormat = FORMATS.RGBA;
    this.samplerType = 0;
  }
  return GLTexture2;
}();
var TextureSystem = function() {
  function TextureSystem2(renderer) {
    this.renderer = renderer;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture();
    this.hasIntegerTextures = false;
  }
  TextureSystem2.prototype.contextChange = function() {
    var gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (var i = 0; i < maxTextures; i++) {
      this.boundTextures[i] = null;
    }
    this.emptyTextures = {};
    var emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (var i = 0; i < 6; i++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (var i = 0; i < this.boundTextures.length; i++) {
      this.bind(null, i);
    }
  };
  TextureSystem2.prototype.bind = function(texture, location) {
    if (location === void 0) {
      location = 0;
    }
    var gl = this.gl;
    texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();
    if (texture && texture.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location] !== texture) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture);
      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      this.boundTextures[location] = texture;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  };
  TextureSystem2.prototype.reset = function() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (var i = 0; i < this.boundTextures.length; i++) {
      this.boundTextures[i] = this.unknownTexture;
    }
  };
  TextureSystem2.prototype.unbind = function(texture) {
    var _a = this, gl = _a.gl, boundTextures = _a.boundTextures;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (var i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === this.unknownTexture) {
          this.bind(null, i);
        }
      }
    }
    for (var i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === texture) {
        if (this.currentLocation !== i) {
          gl.activeTexture(gl.TEXTURE0 + i);
          this.currentLocation = i;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i] = null;
      }
    }
  };
  TextureSystem2.prototype.ensureSamplerType = function(maxTextures) {
    var _a = this, boundTextures = _a.boundTextures, hasIntegerTextures = _a.hasIntegerTextures, CONTEXT_UID = _a.CONTEXT_UID;
    if (!hasIntegerTextures) {
      return;
    }
    for (var i = maxTextures - 1; i >= 0; --i) {
      var tex = boundTextures[i];
      if (tex) {
        var glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  };
  TextureSystem2.prototype.initTexture = function(texture) {
    var glTexture = new GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  };
  TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
    var _a, _b;
    glTexture.internalFormat = (_b = (_a = this.internalFormats[texture.type]) === null || _a === void 0 ? void 0 : _a[texture.format]) !== null && _b !== void 0 ? _b : texture.format;
    if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  };
  TextureSystem2.prototype.updateTexture = function(texture) {
    var glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    var renderer = this.renderer;
    this.initTextureType(texture, glTexture);
    if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) {
      if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      var width = texture.realWidth;
      var height = texture.realHeight;
      var gl = renderer.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  };
  TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
    var gl = this.gl;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        var i = this.managedTextures.indexOf(texture);
        if (i !== -1) {
          removeItems(this.managedTextures, i, 1);
        }
      }
    }
  };
  TextureSystem2.prototype.updateTextureStyle = function(texture) {
    var glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
      ;
    else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  };
  TextureSystem2.prototype.setStyle = function(texture, glTexture) {
    var gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
        var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  };
  TextureSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return TextureSystem2;
}();
var _systems = {
  __proto__: null,
  FilterSystem,
  BatchSystem,
  ContextSystem,
  FramebufferSystem,
  GeometrySystem,
  MaskSystem,
  ScissorSystem,
  StencilSystem,
  ProjectionSystem,
  RenderTextureSystem,
  ShaderSystem,
  StateSystem,
  TextureGCSystem,
  TextureSystem
};
var tempMatrix = new Matrix();
var AbstractRenderer = function(_super) {
  __extends(AbstractRenderer2, _super);
  function AbstractRenderer2(type, options) {
    if (type === void 0) {
      type = RENDERER_TYPE.UNKNOWN;
    }
    var _this = _super.call(this) || this;
    options = Object.assign({}, settings.RENDER_OPTIONS, options);
    _this.options = options;
    _this.type = type;
    _this.screen = new Rectangle(0, 0, options.width, options.height);
    _this.view = options.view || settings.ADAPTER.createCanvas();
    _this.resolution = options.resolution || settings.RESOLUTION;
    _this.useContextAlpha = options.useContextAlpha;
    _this.autoDensity = !!options.autoDensity;
    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
    _this.clearBeforeRender = options.clearBeforeRender;
    _this._backgroundColor = 0;
    _this._backgroundColorRgba = [0, 0, 0, 1];
    _this._backgroundColorString = "#000000";
    _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
    _this.backgroundAlpha = options.backgroundAlpha;
    if (options.transparent !== void 0) {
      deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
      _this.useContextAlpha = options.transparent;
      _this.backgroundAlpha = options.transparent ? 0 : 1;
    }
    _this._lastObjectRendered = null;
    _this.plugins = {};
    return _this;
  }
  AbstractRenderer2.prototype.initPlugins = function(staticMap) {
    for (var o in staticMap) {
      this.plugins[o] = new staticMap[o](this);
    }
  };
  Object.defineProperty(AbstractRenderer2.prototype, "width", {
    get: function() {
      return this.view.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractRenderer2.prototype, "height", {
    get: function() {
      return this.view.height;
    },
    enumerable: false,
    configurable: true
  });
  AbstractRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
    this.view.width = Math.round(desiredScreenWidth * this.resolution);
    this.view.height = Math.round(desiredScreenHeight * this.resolution);
    var screenWidth = this.view.width / this.resolution;
    var screenHeight = this.view.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.view.style.width = screenWidth + "px";
      this.view.style.height = screenHeight + "px";
    }
    this.emit("resize", screenWidth, screenHeight);
  };
  AbstractRenderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
    if (options === void 0) {
      options = {};
    }
    if (typeof options === "number") {
      deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options.");
      options = {scaleMode: options, resolution, region};
    }
    var manualRegion = options.region, textureOptions = __rest(options, ["region"]);
    region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0) {
      region.width = 1;
    }
    if (region.height === 0) {
      region.height = 1;
    }
    var renderTexture = RenderTexture.create(__assign({width: region.width, height: region.height}, textureOptions));
    tempMatrix.tx = -region.x;
    tempMatrix.ty = -region.y;
    this.render(displayObject, {
      renderTexture,
      clear: false,
      transform: tempMatrix,
      skipUpdateTransform: !!displayObject.parent
    });
    return renderTexture;
  };
  AbstractRenderer2.prototype.destroy = function(removeView) {
    for (var o in this.plugins) {
      this.plugins[o].destroy();
      this.plugins[o] = null;
    }
    if (removeView && this.view.parentNode) {
      this.view.parentNode.removeChild(this.view);
    }
    var thisAny = this;
    thisAny.plugins = null;
    thisAny.type = RENDERER_TYPE.UNKNOWN;
    thisAny.view = null;
    thisAny.screen = null;
    thisAny._tempDisplayObjectParent = null;
    thisAny.options = null;
    this._backgroundColorRgba = null;
    this._backgroundColorString = null;
    this._lastObjectRendered = null;
  };
  Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
    get: function() {
      return this._backgroundColor;
    },
    set: function(value) {
      this._backgroundColor = value;
      this._backgroundColorString = hex2string(value);
      hex2rgb(value, this._backgroundColorRgba);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractRenderer2.prototype, "backgroundAlpha", {
    get: function() {
      return this._backgroundColorRgba[3];
    },
    set: function(value) {
      this._backgroundColorRgba[3] = value;
    },
    enumerable: false,
    configurable: true
  });
  return AbstractRenderer2;
}(EventEmitter);
var GLBuffer = function() {
  function GLBuffer2(buffer) {
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
  return GLBuffer2;
}();
var BufferSystem = function() {
  function BufferSystem2(renderer) {
    this.renderer = renderer;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  BufferSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  BufferSystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  };
  BufferSystem2.prototype.bind = function(buffer) {
    var _a = this, gl = _a.gl, CONTEXT_UID = _a.CONTEXT_UID;
    var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  };
  BufferSystem2.prototype.bindBufferBase = function(buffer, index) {
    var _a = this, gl = _a.gl, CONTEXT_UID = _a.CONTEXT_UID;
    if (this.boundBufferBases[index] !== buffer) {
      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  };
  BufferSystem2.prototype.bindBufferRange = function(buffer, index, offset) {
    var _a = this, gl = _a.gl, CONTEXT_UID = _a.CONTEXT_UID;
    offset = offset || 0;
    var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  };
  BufferSystem2.prototype.update = function(buffer) {
    var _a = this, gl = _a.gl, CONTEXT_UID = _a.CONTEXT_UID;
    var glBuffer = buffer._glBuffers[CONTEXT_UID];
    if (buffer._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(buffer.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer.data.byteLength) {
      gl.bufferSubData(buffer.type, 0, buffer.data);
    } else {
      var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer.data.byteLength;
      gl.bufferData(buffer.type, buffer.data, drawType);
    }
  };
  BufferSystem2.prototype.dispose = function(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id]) {
      return;
    }
    delete this.managedBuffers[buffer.id];
    var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
    var gl = this.gl;
    buffer.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer._glBuffers[this.CONTEXT_UID];
  };
  BufferSystem2.prototype.disposeAll = function(contextLost) {
    var all = Object.keys(this.managedBuffers);
    for (var i = 0; i < all.length; i++) {
      this.dispose(this.managedBuffers[all[i]], contextLost);
    }
  };
  BufferSystem2.prototype.createGLBuffer = function(buffer) {
    var _a = this, CONTEXT_UID = _a.CONTEXT_UID, gl = _a.gl;
    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer.id] = buffer;
    buffer.disposeRunner.add(this);
    return buffer._glBuffers[CONTEXT_UID];
  };
  return BufferSystem2;
}();
var Renderer = function(_super) {
  __extends(Renderer2, _super);
  function Renderer2(options) {
    var _this = _super.call(this, RENDERER_TYPE.WEBGL, options) || this;
    options = _this.options;
    _this.gl = null;
    _this.CONTEXT_UID = 0;
    _this.runners = {
      destroy: new Runner("destroy"),
      contextChange: new Runner("contextChange"),
      reset: new Runner("reset"),
      update: new Runner("update"),
      postrender: new Runner("postrender"),
      prerender: new Runner("prerender"),
      resize: new Runner("resize")
    };
    _this.runners.contextChange.add(_this);
    _this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, true);
    _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
    _this.initPlugins(Renderer2.__plugins);
    _this.multisample = void 0;
    if (options.context) {
      _this.context.initFromContext(options.context);
    } else {
      _this.context.initFromOptions({
        alpha: !!_this.useContextAlpha,
        antialias: options.antialias,
        premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: _this.options.powerPreference
      });
    }
    _this.renderingToScreen = true;
    sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
    _this.resize(_this.options.width, _this.options.height);
    return _this;
  }
  Renderer2.create = function(options) {
    if (isWebGLSupported()) {
      return new Renderer2(options);
    }
    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
  };
  Renderer2.prototype.contextChange = function() {
    var gl = this.gl;
    var samples;
    if (this.context.webGLVersion === 1) {
      var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= MSAA_QUALITY.HIGH) {
      this.multisample = MSAA_QUALITY.HIGH;
    } else if (samples >= MSAA_QUALITY.MEDIUM) {
      this.multisample = MSAA_QUALITY.MEDIUM;
    } else if (samples >= MSAA_QUALITY.LOW) {
      this.multisample = MSAA_QUALITY.LOW;
    } else {
      this.multisample = MSAA_QUALITY.NONE;
    }
  };
  Renderer2.prototype.addSystem = function(ClassRef, name) {
    var system = new ClassRef(this);
    if (this[name]) {
      throw new Error('Whoops! The name "' + name + '" is already in use');
    }
    this[name] = system;
    for (var i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  };
  Renderer2.prototype.render = function(displayObject, options) {
    var renderTexture;
    var clear;
    var transform;
    var skipUpdateTransform;
    if (options) {
      if (options instanceof RenderTexture) {
        deprecation("6.0.0", "Renderer#render arguments changed, use options instead.");
        renderTexture = options;
        clear = arguments[2];
        transform = arguments[3];
        skipUpdateTransform = arguments[4];
      } else {
        renderTexture = options.renderTexture;
        clear = options.clear;
        transform = options.transform;
        skipUpdateTransform = options.skipUpdateTransform;
      }
    }
    this.renderingToScreen = !renderTexture;
    this.runners.prerender.emit();
    this.emit("prerender");
    this.projection.transform = transform;
    if (this.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this._lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      var cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    this.renderTexture.bind(renderTexture);
    this.batch.currentRenderer.start();
    if (clear !== void 0 ? clear : this.clearBeforeRender) {
      this.renderTexture.clear();
    }
    displayObject.render(this);
    this.batch.currentRenderer.flush();
    if (renderTexture) {
      renderTexture.baseTexture.update();
    }
    this.runners.postrender.emit();
    this.projection.transform = null;
    this.emit("postrender");
  };
  Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
    if (options === void 0) {
      options = {};
    }
    var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);
    this.framebuffer.blit();
    return renderTexture;
  };
  Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
    _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
    this.runners.resize.emit(this.screen.height, this.screen.width);
  };
  Renderer2.prototype.reset = function() {
    this.runners.reset.emit();
    return this;
  };
  Renderer2.prototype.clear = function() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  };
  Renderer2.prototype.destroy = function(removeView) {
    this.runners.destroy.emit();
    for (var r in this.runners) {
      this.runners[r].destroy();
    }
    _super.prototype.destroy.call(this, removeView);
    this.gl = null;
  };
  Object.defineProperty(Renderer2.prototype, "extract", {
    get: function() {
      deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
      return this.plugins.extract;
    },
    enumerable: false,
    configurable: true
  });
  Renderer2.registerPlugin = function(pluginName, ctor) {
    deprecation("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead.");
    extensions$1.add({
      name: pluginName,
      type: ExtensionType.RendererPlugin,
      ref: ctor
    });
  };
  Renderer2.__plugins = {};
  return Renderer2;
}(AbstractRenderer);
extensions$1.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
function autoDetectRenderer(options) {
  return Renderer.create(options);
}
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultVertex$1 = $defaultVertex;
var defaultFilterVertex = $defaultFilterVertex;
var System = function() {
  function System2(renderer) {
    deprecation("6.1.0", "System class is deprecated, implemement ISystem interface instead.");
    this.renderer = renderer;
  }
  System2.prototype.destroy = function() {
    this.renderer = null;
  };
  return System2;
}();
var BatchDrawCall = function() {
  function BatchDrawCall2() {
    this.texArray = null;
    this.blend = 0;
    this.type = DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
  return BatchDrawCall2;
}();
var BatchTextureArray = function() {
  function BatchTextureArray2() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  BatchTextureArray2.prototype.clear = function() {
    for (var i = 0; i < this.count; i++) {
      this.elements[i] = null;
    }
    this.count = 0;
  };
  return BatchTextureArray2;
}();
var ViewableBuffer = function() {
  function ViewableBuffer2(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
    get: function() {
      if (!this._int8View) {
        this._int8View = new Int8Array(this.rawBinaryData);
      }
      return this._int8View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
    get: function() {
      if (!this._uint8View) {
        this._uint8View = new Uint8Array(this.rawBinaryData);
      }
      return this._uint8View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
    get: function() {
      if (!this._int16View) {
        this._int16View = new Int16Array(this.rawBinaryData);
      }
      return this._int16View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
    get: function() {
      if (!this._uint16View) {
        this._uint16View = new Uint16Array(this.rawBinaryData);
      }
      return this._uint16View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
    get: function() {
      if (!this._int32View) {
        this._int32View = new Int32Array(this.rawBinaryData);
      }
      return this._int32View;
    },
    enumerable: false,
    configurable: true
  });
  ViewableBuffer2.prototype.view = function(type) {
    return this[type + "View"];
  };
  ViewableBuffer2.prototype.destroy = function() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  };
  ViewableBuffer2.sizeOf = function(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(type + " isn't a valid view type");
    }
  };
  return ViewableBuffer2;
}();
var AbstractBatchRenderer = function(_super) {
  __extends(AbstractBatchRenderer2, _super);
  function AbstractBatchRenderer2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.shaderGenerator = null;
    _this.geometryClass = null;
    _this.vertexSize = null;
    _this.state = State.for2d();
    _this.size = settings.SPRITE_BATCH_SIZE * 4;
    _this._vertexCount = 0;
    _this._indexCount = 0;
    _this._bufferedElements = [];
    _this._bufferedTextures = [];
    _this._bufferSize = 0;
    _this._shader = null;
    _this._packedGeometries = [];
    _this._packedGeometryPoolSize = 2;
    _this._flushId = 0;
    _this._aBuffers = {};
    _this._iBuffers = {};
    _this.MAX_TEXTURES = 1;
    _this.renderer.on("prerender", _this.onPrerender, _this);
    renderer.runners.contextChange.add(_this);
    _this._dcIndex = 0;
    _this._aIndex = 0;
    _this._iIndex = 0;
    _this._attributeBuffer = null;
    _this._indexBuffer = null;
    _this._tempBoundTextures = [];
    return _this;
  }
  AbstractBatchRenderer2.prototype.contextChange = function() {
    var gl = this.renderer.gl;
    if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
      this.MAX_TEXTURES = 1;
    } else {
      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
      this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
    for (var i = 0; i < this._packedGeometryPoolSize; i++) {
      this._packedGeometries[i] = new this.geometryClass();
    }
    this.initFlushBuffers();
  };
  AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
    var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
    var MAX_SPRITES = this.size / 4;
    var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray());
    }
    for (var i = 0; i < this.MAX_TEXTURES; i++) {
      this._tempBoundTextures[i] = null;
    }
  };
  AbstractBatchRenderer2.prototype.onPrerender = function() {
    this._flushId = 0;
  };
  AbstractBatchRenderer2.prototype.render = function(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  };
  AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
    var _a = this, textures = _a._bufferedTextures, MAX_TEXTURES = _a.MAX_TEXTURES;
    var textureArrays = AbstractBatchRenderer2._textureArrayPool;
    var batch = this.renderer.batch;
    var boundTextures = this._tempBoundTextures;
    var touch = this.renderer.textureGC.count;
    var TICK = ++BaseTexture._globalBatch;
    var countTexArrays = 0;
    var texArray = textureArrays[0];
    var start = 0;
    batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
    for (var i = 0; i < this._bufferSize; ++i) {
      var tex = textures[i];
      textures[i] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= MAX_TEXTURES) {
        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start, i);
        start = i;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (var i = 0; i < boundTextures.length; i++) {
      boundTextures[i] = null;
    }
    BaseTexture._globalBatch = TICK;
  };
  AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start, finish) {
    var _a = this, elements = _a._bufferedElements, _attributeBuffer = _a._attributeBuffer, _indexBuffer = _a._indexBuffer, vertexSize = _a.vertexSize;
    var drawCalls = AbstractBatchRenderer2._drawCallPool;
    var dcIndex = this._dcIndex;
    var aIndex = this._aIndex;
    var iIndex = this._iIndex;
    var drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (var i = start; i < finish; ++i) {
      var sprite = elements[i];
      var tex = sprite._texture.baseTexture;
      var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i] = null;
      if (start < i && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  };
  AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
    var textureSystem = this.renderer.texture;
    for (var j = 0; j < texArray.count; j++) {
      textureSystem.bind(texArray.elements[j], texArray.ids[j]);
      texArray.elements[j] = null;
    }
    texArray.count = 0;
  };
  AbstractBatchRenderer2.prototype.updateGeometry = function() {
    var _a = this, packedGeometries = _a._packedGeometries, attributeBuffer = _a._attributeBuffer, indexBuffer = _a._indexBuffer;
    if (!settings.CAN_UPLOAD_SAME_BUFFER) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  };
  AbstractBatchRenderer2.prototype.drawBatches = function() {
    var dcCount = this._dcIndex;
    var _a = this.renderer, gl = _a.gl, stateSystem = _a.state;
    var drawCalls = AbstractBatchRenderer2._drawCallPool;
    var curTexArray = null;
    for (var i = 0; i < dcCount; i++) {
      var _b = drawCalls[i], texArray = _b.texArray, type = _b.type, size = _b.size, start = _b.start, blend = _b.blend;
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  };
  AbstractBatchRenderer2.prototype.flush = function() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  };
  AbstractBatchRenderer2.prototype.start = function() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
    this.renderer.shader.bind(this._shader);
    if (settings.CAN_UPLOAD_SAME_BUFFER) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  };
  AbstractBatchRenderer2.prototype.stop = function() {
    this.flush();
  };
  AbstractBatchRenderer2.prototype.destroy = function() {
    for (var i = 0; i < this._packedGeometryPoolSize; i++) {
      if (this._packedGeometries[i]) {
        this._packedGeometries[i].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    _super.prototype.destroy.call(this);
  };
  AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size) {
    var roundedP2 = nextPow2(Math.ceil(size / 8));
    var roundedSizeIndex = log2(roundedP2);
    var roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    var buffer = this._aBuffers[roundedSize];
    if (!buffer) {
      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer;
  };
  AbstractBatchRenderer2.prototype.getIndexBuffer = function(size) {
    var roundedP2 = nextPow2(Math.ceil(size / 12));
    var roundedSizeIndex = log2(roundedP2);
    var roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    var buffer = this._iBuffers[roundedSizeIndex];
    if (!buffer) {
      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
    }
    return buffer;
  };
  AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
    var packedVertices = aIndex / this.vertexSize;
    var uvs = element.uvs;
    var indicies = element.indices;
    var vertexData = element.vertexData;
    var textureId = element._texture.baseTexture._batchLocation;
    var alpha = Math.min(element.worldAlpha, 1);
    var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
    for (var i = 0; i < vertexData.length; i += 2) {
      float32View[aIndex++] = vertexData[i];
      float32View[aIndex++] = vertexData[i + 1];
      float32View[aIndex++] = uvs[i];
      float32View[aIndex++] = uvs[i + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (var i = 0; i < indicies.length; i++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i];
    }
  };
  AbstractBatchRenderer2._drawCallPool = [];
  AbstractBatchRenderer2._textureArrayPool = [];
  return AbstractBatchRenderer2;
}(ObjectRenderer);
var BatchShaderGenerator = function() {
  function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate2;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (fragTemplate2.indexOf("%count%") < 0) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (fragTemplate2.indexOf("%forloop%") < 0) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
    if (!this.programCache[maxTextures]) {
      var sampleValues = new Int32Array(maxTextures);
      for (var i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.from({uSamplers: sampleValues}, true);
      var fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    var uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  };
  BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
    var src = "";
    src += "\n";
    src += "\n";
    for (var i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxTextures - 1) {
        src += "if(vTextureId < " + i + ".5)";
      }
      src += "\n{";
      src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  };
  return BatchShaderGenerator2;
}();
var BatchGeometry = function(_super) {
  __extends(BatchGeometry2, _super);
  function BatchGeometry2(_static) {
    if (_static === void 0) {
      _static = false;
    }
    var _this = _super.call(this) || this;
    _this._buffer = new Buffer(null, _static, false);
    _this._indexBuffer = new Buffer(null, _static, true);
    _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES.FLOAT).addIndex(_this._indexBuffer);
    return _this;
  }
  return BatchGeometry2;
}(Geometry);
var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var BatchPluginFactory = function() {
  function BatchPluginFactory2() {
  }
  BatchPluginFactory2.create = function(options) {
    var _a = Object.assign({
      vertex: defaultVertex,
      fragment: defaultFragment,
      geometryClass: BatchGeometry,
      vertexSize: 6
    }, options), vertex2 = _a.vertex, fragment2 = _a.fragment, vertexSize = _a.vertexSize, geometryClass = _a.geometryClass;
    return function(_super) {
      __extends(BatchPlugin, _super);
      function BatchPlugin(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
        _this.geometryClass = geometryClass;
        _this.vertexSize = vertexSize;
        return _this;
      }
      return BatchPlugin;
    }(AbstractBatchRenderer);
  };
  Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
    get: function() {
      return defaultFragment;
    },
    enumerable: false,
    configurable: true
  });
  return BatchPluginFactory2;
}();
var BatchRenderer = BatchPluginFactory.create();
Object.assign(BatchRenderer, {
  extension: {
    name: "batch",
    type: ExtensionType.RendererPlugin
  }
});
var resources = {};
var _loop_1 = function(name) {
  Object.defineProperty(resources, name, {
    get: function() {
      deprecation("6.0.0", "PIXI.systems." + name + " has moved to PIXI." + name);
      return _resources[name];
    }
  });
};
for (var name in _resources) {
  _loop_1(name);
}
var systems = {};
var _loop_2 = function(name) {
  Object.defineProperty(systems, name, {
    get: function() {
      deprecation("6.0.0", "PIXI.resources." + name + " has moved to PIXI." + name);
      return _systems[name];
    }
  });
};
for (var name in _systems) {
  _loop_2(name);
}
var VERSION = "6.5.5";

export { AbstractBatchRenderer, AbstractMultiResource, AbstractRenderer, ArrayResource, Attribute, BaseImageResource, BaseRenderTexture, BaseTexture, BatchDrawCall, BatchGeometry, BatchPluginFactory, BatchRenderer, BatchShaderGenerator, BatchSystem, BatchTextureArray, Buffer, BufferResource, CanvasResource, ContextSystem, CubeResource, Filter, FilterState, FilterSystem, Framebuffer, FramebufferSystem, GLFramebuffer, GLProgram, GLTexture, Geometry, GeometrySystem, IGLUniformData, INSTALLED, ImageBitmapResource, ImageResource, MaskData, MaskSystem, ObjectRenderer, Program, ProjectionSystem, Quad, QuadUv, RenderTexture, RenderTexturePool, RenderTextureSystem, Renderer, Resource, SVGResource, ScissorSystem, Shader, ShaderSystem, SpriteMaskFilter, State, StateSystem, StencilSystem, System, Texture, TextureGCSystem, TextureMatrix, TextureSystem, TextureUvs, UniformGroup, VERSION, VideoResource, ViewableBuffer, autoDetectRenderer, autoDetectResource, checkMaxIfStatementsInShader, createUBOElements, defaultFilterVertex, defaultVertex$1 as defaultVertex, generateProgram, generateUniformBufferSync, getTestContext, getUBOData, resources, systems, uniformParsers };
