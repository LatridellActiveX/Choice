import { Sprite } from '@pixi/sprite';
import { Texture } from '@pixi/core';
import { settings } from '@pixi/settings';
import { Rectangle } from '@pixi/math';
import { hex2rgb, string2hex, trimCanvas, sign, hex2string } from '@pixi/utils';

/*!
 * @pixi/text - v6.5.5
 * Compiled Fri, 30 Sep 2022 13:37:53 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var TEXT_GRADIENT;
(function(TEXT_GRADIENT2) {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100,
  leading: 0
};
var genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
var TextStyle = function() {
  function TextStyle2(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  TextStyle2.prototype.clone = function() {
    var clonedProperties = {};
    deepCopyProperties(clonedProperties, this, defaultStyle);
    return new TextStyle2(clonedProperties);
  };
  TextStyle2.prototype.reset = function() {
    deepCopyProperties(this, defaultStyle, defaultStyle);
  };
  Object.defineProperty(TextStyle2.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(align) {
      if (this._align !== align) {
        this._align = align;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "breakWords", {
    get: function() {
      return this._breakWords;
    },
    set: function(breakWords) {
      if (this._breakWords !== breakWords) {
        this._breakWords = breakWords;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadow", {
    get: function() {
      return this._dropShadow;
    },
    set: function(dropShadow) {
      if (this._dropShadow !== dropShadow) {
        this._dropShadow = dropShadow;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
    get: function() {
      return this._dropShadowAlpha;
    },
    set: function(dropShadowAlpha) {
      if (this._dropShadowAlpha !== dropShadowAlpha) {
        this._dropShadowAlpha = dropShadowAlpha;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
    get: function() {
      return this._dropShadowAngle;
    },
    set: function(dropShadowAngle) {
      if (this._dropShadowAngle !== dropShadowAngle) {
        this._dropShadowAngle = dropShadowAngle;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
    get: function() {
      return this._dropShadowBlur;
    },
    set: function(dropShadowBlur) {
      if (this._dropShadowBlur !== dropShadowBlur) {
        this._dropShadowBlur = dropShadowBlur;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
    get: function() {
      return this._dropShadowColor;
    },
    set: function(dropShadowColor) {
      var outputColor = getColor(dropShadowColor);
      if (this._dropShadowColor !== outputColor) {
        this._dropShadowColor = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
    get: function() {
      return this._dropShadowDistance;
    },
    set: function(dropShadowDistance) {
      if (this._dropShadowDistance !== dropShadowDistance) {
        this._dropShadowDistance = dropShadowDistance;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fill", {
    get: function() {
      return this._fill;
    },
    set: function(fill) {
      var outputColor = getColor(fill);
      if (this._fill !== outputColor) {
        this._fill = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
    get: function() {
      return this._fillGradientType;
    },
    set: function(fillGradientType) {
      if (this._fillGradientType !== fillGradientType) {
        this._fillGradientType = fillGradientType;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
    get: function() {
      return this._fillGradientStops;
    },
    set: function(fillGradientStops) {
      if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
        this._fillGradientStops = fillGradientStops;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontFamily", {
    get: function() {
      return this._fontFamily;
    },
    set: function(fontFamily) {
      if (this.fontFamily !== fontFamily) {
        this._fontFamily = fontFamily;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(fontSize) {
      if (this._fontSize !== fontSize) {
        this._fontSize = fontSize;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontStyle", {
    get: function() {
      return this._fontStyle;
    },
    set: function(fontStyle) {
      if (this._fontStyle !== fontStyle) {
        this._fontStyle = fontStyle;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontVariant", {
    get: function() {
      return this._fontVariant;
    },
    set: function(fontVariant) {
      if (this._fontVariant !== fontVariant) {
        this._fontVariant = fontVariant;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontWeight", {
    get: function() {
      return this._fontWeight;
    },
    set: function(fontWeight) {
      if (this._fontWeight !== fontWeight) {
        this._fontWeight = fontWeight;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(letterSpacing) {
      if (this._letterSpacing !== letterSpacing) {
        this._letterSpacing = letterSpacing;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "lineHeight", {
    get: function() {
      return this._lineHeight;
    },
    set: function(lineHeight) {
      if (this._lineHeight !== lineHeight) {
        this._lineHeight = lineHeight;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "leading", {
    get: function() {
      return this._leading;
    },
    set: function(leading) {
      if (this._leading !== leading) {
        this._leading = leading;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "lineJoin", {
    get: function() {
      return this._lineJoin;
    },
    set: function(lineJoin) {
      if (this._lineJoin !== lineJoin) {
        this._lineJoin = lineJoin;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "miterLimit", {
    get: function() {
      return this._miterLimit;
    },
    set: function(miterLimit) {
      if (this._miterLimit !== miterLimit) {
        this._miterLimit = miterLimit;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "padding", {
    get: function() {
      return this._padding;
    },
    set: function(padding) {
      if (this._padding !== padding) {
        this._padding = padding;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "stroke", {
    get: function() {
      return this._stroke;
    },
    set: function(stroke) {
      var outputColor = getColor(stroke);
      if (this._stroke !== outputColor) {
        this._stroke = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
    get: function() {
      return this._strokeThickness;
    },
    set: function(strokeThickness) {
      if (this._strokeThickness !== strokeThickness) {
        this._strokeThickness = strokeThickness;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "textBaseline", {
    get: function() {
      return this._textBaseline;
    },
    set: function(textBaseline) {
      if (this._textBaseline !== textBaseline) {
        this._textBaseline = textBaseline;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "trim", {
    get: function() {
      return this._trim;
    },
    set: function(trim) {
      if (this._trim !== trim) {
        this._trim = trim;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
    get: function() {
      return this._whiteSpace;
    },
    set: function(whiteSpace) {
      if (this._whiteSpace !== whiteSpace) {
        this._whiteSpace = whiteSpace;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "wordWrap", {
    get: function() {
      return this._wordWrap;
    },
    set: function(wordWrap) {
      if (this._wordWrap !== wordWrap) {
        this._wordWrap = wordWrap;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
    get: function() {
      return this._wordWrapWidth;
    },
    set: function(wordWrapWidth) {
      if (this._wordWrapWidth !== wordWrapWidth) {
        this._wordWrapWidth = wordWrapWidth;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  TextStyle2.prototype.toFontString = function() {
    var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
    var fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (var i = fontFamilies.length - 1; i >= 0; i--) {
      var fontFamily = fontFamilies[i].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies[i] = fontFamily;
    }
    return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
  };
  return TextStyle2;
}();
function getSingleColor(color) {
  if (typeof color === "number") {
    return hex2string(color);
  } else if (typeof color === "string") {
    if (color.indexOf("0x") === 0) {
      color = color.replace("0x", "#");
    }
  }
  return color;
}
function getColor(color) {
  if (!Array.isArray(color)) {
    return getSingleColor(color);
  } else {
    for (var i = 0; i < color.length; ++i) {
      color[i] = getSingleColor(color[i]);
    }
    return color;
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (var prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
var TextMetrics = function() {
  function TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  TextMetrics2.measureText = function(text, style, wordWrap, canvas) {
    if (canvas === void 0) {
      canvas = TextMetrics2._canvas;
    }
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    var font = style.toFontString();
    var fontProperties = TextMetrics2.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    var context = canvas.getContext("2d");
    context.font = font;
    var outputText = wordWrap ? TextMetrics2.wordWrap(text, style, canvas) : text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    for (var i = 0; i < lines.length; i++) {
      var lineWidth = context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;
      lineWidths[i] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    var width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  };
  TextMetrics2.wordWrap = function(text, style, canvas) {
    if (canvas === void 0) {
      canvas = TextMetrics2._canvas;
    }
    var context = canvas.getContext("2d");
    var width = 0;
    var line = "";
    var lines = "";
    var cache = Object.create(null);
    var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
    var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
    var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
    var canPrependSpaces = !collapseSpaces;
    var wordWrapWidth = style.wordWrapWidth + letterSpacing;
    var tokens = TextMetrics2.tokenize(text);
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (TextMetrics2.isNewline(token)) {
        if (!collapseNewlines) {
          lines += TextMetrics2.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token);
        var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      var tokenWidth = TextMetrics2.getFromCache(token, letterSpacing, cache, context);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += TextMetrics2.addLine(line);
          line = "";
          width = 0;
        }
        if (TextMetrics2.canBreakWords(token, style.breakWords)) {
          var characters = TextMetrics2.wordWrapSplit(token);
          for (var j = 0; j < characters.length; j++) {
            var char = characters[j];
            var k = 1;
            while (characters[j + k]) {
              var nextChar = characters[j + k];
              var lastChar = char[char.length - 1];
              if (!TextMetrics2.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              k++;
            }
            j += char.length - 1;
            var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache, context);
            if (characterWidth + width > wordWrapWidth) {
              lines += TextMetrics2.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += TextMetrics2.addLine(line);
            line = "";
            width = 0;
          }
          var isLastToken = i === tokens.length - 1;
          lines += TextMetrics2.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += TextMetrics2.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !TextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += TextMetrics2.addLine(line, false);
    return lines;
  };
  TextMetrics2.addLine = function(line, newLine) {
    if (newLine === void 0) {
      newLine = true;
    }
    line = TextMetrics2.trimRight(line);
    line = newLine ? line + "\n" : line;
    return line;
  };
  TextMetrics2.getFromCache = function(key, letterSpacing, cache, context) {
    var width = cache[key];
    if (typeof width !== "number") {
      var spacing = key.length * letterSpacing;
      width = context.measureText(key).width + spacing;
      cache[key] = width;
    }
    return width;
  };
  TextMetrics2.collapseSpaces = function(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  };
  TextMetrics2.collapseNewlines = function(whiteSpace) {
    return whiteSpace === "normal";
  };
  TextMetrics2.trimRight = function(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (var i = text.length - 1; i >= 0; i--) {
      var char = text[i];
      if (!TextMetrics2.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  };
  TextMetrics2.isNewline = function(char) {
    if (typeof char !== "string") {
      return false;
    }
    return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
  };
  TextMetrics2.isBreakingSpace = function(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
  };
  TextMetrics2.tokenize = function(text) {
    var tokens = [];
    var token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (var i = 0; i < text.length; i++) {
      var char = text[i];
      var nextChar = text[i + 1];
      if (TextMetrics2.isBreakingSpace(char, nextChar) || TextMetrics2.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  };
  TextMetrics2.canBreakWords = function(_token, breakWords) {
    return breakWords;
  };
  TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  };
  TextMetrics2.wordWrapSplit = function(token) {
    return token.split("");
  };
  TextMetrics2.measureFont = function(font) {
    if (TextMetrics2._fonts[font]) {
      return TextMetrics2._fonts[font];
    }
    var properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    var canvas = TextMetrics2._canvas;
    var context = TextMetrics2._context;
    context.font = font;
    var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
    var width = Math.ceil(context.measureText(metricsString).width);
    var baseline = Math.ceil(context.measureText(TextMetrics2.BASELINE_SYMBOL).width);
    var height = Math.ceil(TextMetrics2.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = "#f00";
    context.fillRect(0, 0, width, height);
    context.font = font;
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    context.fillText(metricsString, 0, baseline);
    var imagedata = context.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i = 0;
    var idx = 0;
    var stop = false;
    for (i = 0; i < baseline; ++i) {
      for (var j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (var j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    TextMetrics2._fonts[font] = properties;
    return properties;
  };
  TextMetrics2.clearMetrics = function(font) {
    if (font === void 0) {
      font = "";
    }
    if (font) {
      delete TextMetrics2._fonts[font];
    } else {
      TextMetrics2._fonts = {};
    }
  };
  Object.defineProperty(TextMetrics2, "_canvas", {
    get: function() {
      if (!TextMetrics2.__canvas) {
        var canvas = void 0;
        try {
          var c = new OffscreenCanvas(0, 0);
          var context = c.getContext("2d");
          if (context && context.measureText) {
            TextMetrics2.__canvas = c;
            return c;
          }
          canvas = settings.ADAPTER.createCanvas();
        } catch (ex) {
          canvas = settings.ADAPTER.createCanvas();
        }
        canvas.width = canvas.height = 10;
        TextMetrics2.__canvas = canvas;
      }
      return TextMetrics2.__canvas;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextMetrics2, "_context", {
    get: function() {
      if (!TextMetrics2.__context) {
        TextMetrics2.__context = TextMetrics2._canvas.getContext("2d");
      }
      return TextMetrics2.__context;
    },
    enumerable: false,
    configurable: true
  });
  return TextMetrics2;
}();
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|ÉqÅ";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
var Text = function(_super) {
  __extends(Text2, _super);
  function Text2(text, style, canvas) {
    var _this = this;
    var ownCanvas = false;
    if (!canvas) {
      canvas = settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    var texture = Texture.from(canvas);
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    _this = _super.call(this, texture) || this;
    _this._ownCanvas = ownCanvas;
    _this.canvas = canvas;
    _this.context = canvas.getContext("2d");
    _this._resolution = settings.RESOLUTION;
    _this._autoResolution = true;
    _this._text = null;
    _this._style = null;
    _this._styleListener = null;
    _this._font = "";
    _this.text = text;
    _this.style = style;
    _this.localStyleID = -1;
    return _this;
  }
  Text2.prototype.updateText = function(respectDirty) {
    var style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    var context = this.context;
    var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    var width = measured.width;
    var height = measured.height;
    var lines = measured.lines;
    var lineHeight = measured.lineHeight;
    var lineWidths = measured.lineWidths;
    var maxLineWidth = measured.maxLineWidth;
    var fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context.scale(this._resolution, this._resolution);
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context.font = this._font;
    context.lineWidth = style.strokeThickness;
    context.textBaseline = style.textBaseline;
    context.lineJoin = style.lineJoin;
    context.miterLimit = style.miterLimit;
    var linePositionX;
    var linePositionY;
    var passesCount = style.dropShadow ? 2 : 1;
    for (var i = 0; i < passesCount; ++i) {
      var isShadowPass = style.dropShadow && i === 0;
      var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      var dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context.fillStyle = "black";
        context.strokeStyle = "black";
        var dropShadowColor = style.dropShadowColor;
        var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
        var dropShadowBlur = style.dropShadowBlur * this._resolution;
        var dropShadowDistance = style.dropShadowDistance * this._resolution;
        context.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
        context.shadowBlur = dropShadowBlur;
        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context.fillStyle = this._generateFillStyle(style, lines, measured);
        context.strokeStyle = style.stroke;
        context.shadowColor = "black";
        context.shadowBlur = 0;
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
      }
      var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (!Text2.nextLineHeightBehavior || lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (var i_1 = 0; i_1 < lines.length; i_1++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i_1];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  };
  Text2.prototype.drawLetterSpacing = function(text, x, y, isStroke) {
    if (isStroke === void 0) {
      isStroke = false;
    }
    var style = this._style;
    var letterSpacing = style.letterSpacing;
    var supportLetterSpacing = Text2.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
    if (letterSpacing === 0 || supportLetterSpacing) {
      if (supportLetterSpacing) {
        this.context.letterSpacing = letterSpacing;
        this.context.textLetterSpacing = letterSpacing;
      }
      if (isStroke) {
        this.context.strokeText(text, x, y);
      } else {
        this.context.fillText(text, x, y);
      }
      return;
    }
    var currentPosition = x;
    var stringArray = Array.from ? Array.from(text) : text.split("");
    var previousWidth = this.context.measureText(text).width;
    var currentWidth = 0;
    for (var i = 0; i < stringArray.length; ++i) {
      var currentChar = stringArray[i];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y);
      } else {
        this.context.fillText(currentChar, currentPosition, y);
      }
      var textStr = "";
      for (var j = i + 1; j < stringArray.length; ++j) {
        textStr += stringArray[j];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  };
  Text2.prototype.updateTexture = function() {
    var canvas = this.canvas;
    if (this._style.trim) {
      var trimmed = trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    var texture = this._texture;
    var style = this._style;
    var padding = style.trim ? 0 : style.padding;
    var baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture.updateUvs();
    this.dirty = false;
  };
  Text2.prototype._render = function(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    _super.prototype._render.call(this, renderer);
  };
  Text2.prototype.updateTransform = function() {
    this.updateText(true);
    _super.prototype.updateTransform.call(this);
  };
  Text2.prototype.getBounds = function(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return _super.prototype.getBounds.call(this, skipUpdate, rect);
  };
  Text2.prototype.getLocalBounds = function(rect) {
    this.updateText(true);
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  Text2.prototype._calculateBounds = function() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  };
  Text2.prototype._generateFillStyle = function(style, lines, metrics) {
    var fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    var gradient;
    var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    var padding = style.padding || 0;
    var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    var fill = fillStyle.slice();
    var fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      var lengthPlus1 = fill.length + 1;
      for (var i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (var i = 0; i < lines.length; i++) {
        var lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
        var thisLineTop = metrics.lineHeight * i;
        var thisLineGradientStart = thisLineTop;
        if (i > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        var thisLineBottom = thisLineTop + textHeight;
        var nextLineTop = metrics.lineHeight * (i + 1);
        var thisLineGradientEnd = thisLineBottom;
        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (var j = 0; j < fill.length; j++) {
          var lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      var totalIterations = fill.length + 1;
      var currentIteration = 1;
      for (var i = 0; i < fill.length; i++) {
        var stop = void 0;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  };
  Text2.prototype.destroy = function(options) {
    if (typeof options === "boolean") {
      options = {children: options};
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    _super.prototype.destroy.call(this, options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  };
  Object.defineProperty(Text2.prototype, "width", {
    get: function() {
      this.updateText(true);
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(value) {
      this.updateText(true);
      var s = sign(this.scale.x) || 1;
      this.scale.x = s * value / this._texture.orig.width;
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "height", {
    get: function() {
      this.updateText(true);
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(value) {
      this.updateText(true);
      var s = sign(this.scale.y) || 1;
      this.scale.y = s * value / this._texture.orig.height;
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "style", {
    get: function() {
      return this._style;
    },
    set: function(style) {
      style = style || {};
      if (style instanceof TextStyle) {
        this._style = style;
      } else {
        this._style = new TextStyle(style);
      }
      this.localStyleID = -1;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._autoResolution = false;
      if (this._resolution === value) {
        return;
      }
      this._resolution = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Text2.nextLineHeightBehavior = false;
  Text2.experimentalLetterSpacing = false;
  return Text2;
}(Sprite);

export { TEXT_GRADIENT, Text, TextMetrics, TextStyle };
